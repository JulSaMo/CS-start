// 2022.08.23 Noel

<br/>
<br/>

# ❤️트랜잭션 격리 수준(Transaction Isolation Level)



#### 🧡 트랜잭션 격리수준(isolation level)이란?

> 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어 있는지를 나타내는 것

- 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준
- 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정

<br/>

**트랜잭션 격리수준의 필요성**

- 데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록함
  -  Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요!
- 하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능이 떨어짐
- But! 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생할 수 있음

=> 따라서 최대한 효율적인 Locking 방법이 필요함!

<br/>

```참고
🤔 Lock이 뭐야..?
Lock 
- 트랜잭션 처리의 순차성을 보장하기 위한 방법 (동시성 제어)
- DBMS마다 Lock를 구현하는 방식이 다르기 때문에 DBMS을 효과적으로 이용하기 위해 해당 DB의 Lock에 대한 이해가 요구

① 공유 락(Shared lock) 
	- 데이터를 읽을떄, 사용되어지는 Lock
	- Shared lock은 Shared lock끼지 동시 접근이 가능
	- 하지만, Shared lock이 설정된 데이터에 Exclusive lock을 사용할 수 없음

② 베타 락(Exclusive lock)
	- 데이터를 변경하고자 할때 사용되며, 트랜잭션이 완료될 때까지 유지된다.
	- Lock이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없음
	- 해당 Lock는 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 Lock를 설정할 수 없음

```

<br/>
<br/>
<hr/>

#### 🧡 트랜잭션 격리수준(isolation level) 종류

1. **Read Uncommitted (레벨 0)**

   > SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층

   - 트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함
   - 데이터베이스의 **일관성을 유지하는 것이 불가능함**
   - Dirty Read 발생

   ``` 참고
   A 트랜잭션 : 10번 사원의 나이를 27 -> 28로 바꾸고 커밋하지 않음
   B 트랜잭션 : 10번 사원의 나이 조회 : 결과 28 -> 더티 리드(Dirty Read)
   
   이 이후 A 트랜잭션에서 문제가 발생해 Rollback함
   B 트랜잭션은 10번 사원이 여전히 28이라고 생각하고 로직 수행
   
   이런식으로 사용자1이 데이터를 변경하는 동안,
   아직 완료 되지 않은(Uncommitted) 트랜잭션이지만 변경하는 데이터를 읽을 수 있음
   데이터 정합성에 문제가 많아짐
   ```

<br/>  

2. **Read committed (레벨 1)**

   > SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층

   - 트랜잭션이 수행되는 동안 **다른 트랜잭션이 접근할 수 없어 대기**하게 됨

   - Commit이 이루어진 트랜잭션만 조회 가능

   - 대부분의 SQL 서버가 Default로 사용하는 Isolation Level임
   - Non-Repeatable Read 발생

   ``` 예시
   B 트랜잭션 : 10번 사원 나이 조회 : 결과 27
   A 트랜잭션 : 10번 사원나이 27 -> 28로 바꾸고 커밋
   B 트랜잭션 : 10번 사원 나이 조회 : 결과 28
   
   사용자1이 데이터를 변경하는 동안 사용자2는 해당 데이터에 접근 불가능
   ```
   
<br/>

3. **Repeatable Read (레벨 2)**

   > 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층

   - 트랜잭션이 범위 내에서 **조회한 데이터 내용이 항상 동일함을 보장**함

   - 다른 사용자는 **트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능**

   - MySQL에서 Default로 사용하는 Isolation Level
   - Non-Repeatable Read 부정합이 발생하지 않음

   ```예시
   10번 트랜잭션 : 500번 사원 조회
   12번 트랜잭션 : 500번 사원 이름 변경 후 커밋
   10번 트랜잭션 : 500번 사원 다시 조회 -> undo 영역에 백업된 데이터 반환
   
   즉 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(커밋된) 것만 보게됨
   - 모든 InnoDB의 트랜잭션은 순차적으로 증가하는 고유한 트랜잭션 번호를 갖고있음
   - undo 영역에 백업된 모든 레코드는 변경을 발생기킨 트랜잭션의 번호 포함
   ```

   <br/>

4. **Serializable (레벨 3)**

   > 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층

   - 완벽한 읽기 일관성 모드를 제공함

   - 다른 사용자는 **트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능**

<br/>

```결론
결론
- 레벨이 높아질수록 트랜잭션 간 고립 정도가 높아지며, 성능이 덜어지는 것이 일반적
- 일반적인 온라인 서비스에서는 Read committed (레벨 1) / Repeatable Read (레벨 2)을 사용함
```

<br/>
<br/>
<hr/>

#### 🧡 트랜잭션 격리수준(isolation level) 선택 시 고려사항

Isolation Level에 대한 조정은, `동시성`과 데이터 `무결성`에 연관되어 있음

>  동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨

- 레벨을 높게 조정할 수록 발생하는 비용이 증가함

<br/>


```참고
🤔 무결성(integrity)
- 데이터의 정확성, 일관성, 유효성이 유지되는 것

① 개채 무결성 
	- 모든 테이블이 기본키로 선택된 필드를 가져야함 (기본 키를 가져야함)
	- 고유햔 값, NULL 허용 하지 않음

② 참조 무결성
	- 참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지
	- 참조 대상이 존재하지 않는 외래 키를 허용하지 않음
		> RESTRICTED : 레코드를 참고하고 있는 개체가 있다면, 변경 또는 삭제 연산 취소
    > CASCADE : 레코드를 참조하고 있는 개체도 변경 또는 삭제
    > SET NULL : 레코드를 참고하고 있는 개체의 값을 NULL로 설정
	
③ 도메인 무결성
	- 테이블에 존재하는 필드의 무결성 보장
	- 필드의 타입, null 값의 허용 등 사항을 저으이하고 올바른 데이터가 입력되었는지 확인
	
④ 무결성 규칙
	- 데이터의 무결성을 지키기 위한 모든 제약사항, 데이터 베이스 전체에 공통적으로 적용되는 규칙

```

<br/>
<br/>
<hr/>

#### 🧡 낮은 단계 트랜잭션 격리수준(isolation level) 활용 시 발생하는 현상

**Dirty Read**

- 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상

- 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우

<br/>
  

**Non-Repeatable Read**

- 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

<br/>

**Phantom Read**

- 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상

- 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임

| 격리수준                      | Dirty Read | Non-Repeatable Read | Phantom Read |
| ----------------------------- | ---------- | ------------------- | ------------ |
| Read Uncommitted<br/>(레벨 0) | O          | O                   | O            |
| Read committed <br/>(레벨 1)  | -          | O                   | O            |
| Repeatable Read<br/> (레벨 2) | -          | -                   | O            |
| Serializable<br/> (레벨 3)    | -          | -                   | -            |


<br/>
<br/>
<br/>
<br/>
<hr/>

출처

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction%20Isolation%20Level.md#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80transaction-isolation-level

https://dar0m.tistory.com/225

https://code-lab1.tistory.com/51
