// 2022.08.23 Noel



# ❤️ DB 트랜잭션(Transaction)



#### 🧡 트랜잭션 이란?

> 트랜잭션(Transaction)은 **데이터베이스의 상태를 변환시키는 하나의 논리적 작업 단위** 라고 할 수 있으며, 트랜잭션에는 여러개의 연산이 수행될 수 있음

- 하나의 트랜잭션은 `Commit`되거나 `Rollback `된다.
- 트랜잭션은 `SELECT` `UPDATE` `INSERT` `DELETE`와 같은 연산을 수행하여 데이터 베이스의 상태를 변화시키는 작업 단위❗️

- 트랜잭션은 하나의 논리적인 작업 단위이기 떄문에, `여러개의 작업을 하나의 논리적인 단위로 묶어서 반영과 복구를 조정할 수 있기 위해 사용`한다. 
  - 따라서 데이터의 부정합이 일어났을 경우, `Rollback`해 데이터의 부정합의 방지할 수 있음

- 트랜잭션은 작업의 완전성을 보장해줌
  - 논리적인 작업 set를 모두 완벽하게 처리하거나 또는 처리못할 경우에는 원상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어 주는 기능
- `사용자 입장에서는 작업을 논리적 단위`로 이해 가능하고 `시스템 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위`가 됨



작업 단위 → **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는 것**

```
예시) 사용자 A가 사용자 B에게 만원을 송금한다.

* 이때 DB 작업
- 1. 사용자 A의 계좌에서 만원을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
- 2. 사용자 B의 계좌에 만원을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경

현재 작업 단위 : 출금 UPDATE문 + 입금 UPDATE문
→ 이를 통틀어 하나의 트랜잭션이라고 한다.
- 위 두 쿼리문 모두 성공적으로 완료되어야만 "하나의 작업(트랜잭션)"이 완료되는 것이다. `Commit`
- 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야한다. `Rollback`
```

즉, **하나의 트랜잭션 설계를 잘 만드는 것이 데이터를 다룰 때 많은 이점을 가져옴**



<hr/>

#### 🧡 트랜잭션 특징(ACID) 

1. **원자성 (Atomicity)**

>  트랜잭션이 데이터베이스에 모두 반영되거나 혹은 전혀 반영 되지 않아야함

- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야하며, 모두가 완벽히 수행되지 않고  어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소 되어야함



2. **일관성(Consistency)**

>  트랜잭션의 작업 처리결과가 항상 일관성 있어야함

-  시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 수행 완료 후의 `상태`가 같아야함
  - 상태 : `트랜잭션 수행이 보존해야할 일관성`
    - 명시적인 일관성 
      - 기본 키, 외래 키 등과 같은 무결성 제약조건
      - 무결성 제약조건을 해치지 않는 데이터들에 대해서만 트랜잭션이 성공적으로 수행되어야함
    - 비명시적인 일관성 
      - ex. 계좌 이체에서 A 계좌 출금 -> B 계좌 입금한다면?
      - 트랜잭션의 전과 후 두 계좌 잔고의 합이 같아야함



3. **독립성(Isolation)**

> 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우, 
>
> 어떤 하나의 트랜잭션이라도 다른 트랜잭션 연산에 끼어 들 수 없음

- 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행결과를 참조 할 수 없음



4. **지속성(Durability)**

> 트랜잭션이 성공적으로 완료 되었을 경우, 결과는 영구적으로 반영되어야 함



<hr/>

#### 🧡 트랜잭션의 Comnit과 Rollback

**Commit**

- Commit 연산은 하나의 트랙잭션이 성공적으로 끝났고, 데이터베이스가 일관성 있는 상태에 있을때, 하나의 트랜잭션이 끝났음을 알려주기 위해 사용하는 연산



**Rollback**

- Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 **트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산**



``` 참고!
⚠️ 면접 대비
상황이 주어지면 DB 측면에서 어떻게 해결할 수 있을지 대답할 수 있어야함
```



<hr/>

#### 🧡 트랜잭션의 상태

![image-20220823195821845](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220823195821845.png)

- 활동(Active)
  - 트랜잭션의 활동 상태, 트랜잭션이 실행중이며 동작 중인 상태
- 부분 완료 (Partially Committed)
  - 트랜잭션의 Commit 명령이 도착한 상태
  - 트랜잭션의 Commit 이전의 SQL문이 수행되고, commit만 남은 상태를 말함
- 완료(Committed)
  - 트랜잭션 완료 상태, 트랜잭션이 정상적으로 완료된 상태
- 실패(Failed)
  - 트랜잭션 실패 상태, 트랜잭션이 더 이상 정상적으로 진행될 수 없는 상태
- 취소(Aborted)
  - 트랜잭션 취소 상태, 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태



**부분완료와 완료의 차이점**

- Commit 요청이 들어오면  ➡︎ 부분완료 상태
- 이후 Commit을 문제없이 수행 할 수 있다면  ➡︎ 완료 상태
  - 만약 오류가 발생하면  ➡︎ 실패상태 

- 부분완료는 Commit 요청이 들어왔을때, 완료는 Commit을 정상적으로 완료했을때



<hr/>

#### 🧡 Transaction 관리를 위한 DBMS의 전략

이해를 하기위한 2가지 개념 DBMS의 개략적인 구조와 버퍼 관리자 및 트랜잭션 관리와 연관된 버퍼 관리 정책에 대한 이해가 필요



1. **DBMS의 구조**

   ![image-20220823193357362](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220823193357362.png)

- 크게 2가지로 구분 
  - Query Processor (질의 처리기)
  -  Storage System (저장 시스템)

- 데이터 베이스 시스템 저장공간
  - 보통 비휘발성 저장 장치인 디스크에 데이터 저장
  - 일부분은 Main Memory에 저장
- 입출력 단위
  - 고정 길이의 page 단위로 disk에 읽거나 씀



2. **Page Buffer Manager or Buffer Manager**

DBMS의 Storage System에 속하는 모듈 중 하나로, Main Memory에 유지하는 페이지를 관리하는 모듈

> Buffer 관리 정책에 따라, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 가져온다.



<hr/>

#### 🧡 UNDO는 왜 필요할까?

>  수정된 Page들이 **Buffer 교체 알고리즘에 따라서 디스크에 출력**될 수 있음.
>
> Buffer 교체는 **transaction과는 무관하게 buffer의 상태에 따라서, 결정됨**. 
>
> 이로 인해, 정상적으로 종료되지 않은 transaction이 변경한 page들은 원상 복구 되어야 하는데, 이 복구를 undo라고 함



- 트랜잭션 종료전에 수정된 Page를 디스크에 쓰지 않은 경우

  - UNDO 오퍼레이션은 메모리 버퍼에 대해서만 이루어지면됨 
  - 매우 간단하지만  매우 큰 크기의 메모리 버퍼가 필요

  

- 트랜잭션 종료전에 수정된 Page를 디스크에 쓴 경우

  - steal

    - 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
    - 대부분의 DBMS가 채택하는 Buffer 관리 정책

    - 수정된 페이지가 어떠한 시점에도 디스크에 써질 수 있기 때문에 필연적으로 UNDO logging과 복구를 필요로 함.

  - ¬steal 

    - 수정된 페이지들을 최소한 트랜잭션 종료시점 EOT (End Of Transaction)까지는 버퍼에 유지하는 정책

    - UNDO 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함.



<hr/>

#### 🧡 REDO는 왜 필요할까?

>  commit한 트랜잭션의 수정은 어떤 경우에도 유지(durability)되어야 한다.
>
>  이미 commit한 트랜잭션의 수정을 재반영하는 복구 작업을 **REDO 복구**라고 함
>
> UNDO와 마찬가지로 Buffer 관리 정책에 영향을 받음



- 트랜잭션이 종료되는 시점에 수정한 페이지들을 디스크에 쓰는 경우

  - FORCE
    - 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하는 정책
    - Transaction이 commit 되었을 때 수정된 페이지들이 disk 상에 반영되므로 redo 필요 없음

  - ¬FORCE
    -  수정했던 페이지를 트랜잭션 커밋 시점에 디스크에 반영하지 않는 정책
    - transaction이 disk 상의 db에 반영되지 않을 수 있기에 redo 복구가 필요
    - 대부분의 DBMS 정책



```요약
🗄정리
DBMS는 버퍼 관리 정책으로 STEAL과 ¬FORCE 정책을 채택
-> 이로 인해서 UNDO 복구와 REDO 복구가 모두 필요
```





<hr/>

출처

https://d2.naver.com/helloworld/407507

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Database/Transaction.md

https://github.com/NKLCWDT/cs/blob/main/Database/Transaction.md

https://code-lab1.tistory.com/51