#20220822 Noel



# ❤️ Index(인덱스)

### Index란?

> 데이터베이스 테이블에 대한 검색 성능 속도를 높여주는 자료구조 

**특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데디터의 물리적 주소와 함께 저장**된다. 

또한 인덱스 생성 시 **오름차순으로 정렬**하기 때문에 정렬된 주소 체계라고 표현 할 수 있다.

(데이터 베이스에서 테이블의 모든 데이터를 검색하면 시간이 오래 걸리기떄문에 데이터와 데이터의 위치를 포함한 자료구조를 생성하는것!)

인덱스를 책에서의 목차라고 생각하면 좋음, 

책에서 원하는 내용을 찾을때 목차나 색인을 이용하면 훨씬 빠르게 찾을 수 있듯이 테이블에서 원하는 데이터를 찾기 위해 인덱스를 이용하면 빠르게 찾을 수 있음 `데이터 = 책의 내용` `인덱스 = 책의 목차` `물리적 주소 = 책의 페이지 번호`



<hr/>

#### 🧡 인덱스의 원리

초기 TABLE 생성 시 `MYD` ` MYI` ` FRM` 3개의 파일이 만들어짐

> FRM : 테이블 구조 저장 파일

> MYD : 실제 데이터 파일

> MYI : Index 정보 파일 (Index 사용 시 생성)

사용자가 **인덱스를 만들면 MYI에 해당 컬럼을 색인화 하여 저장**



<hr/>

#### 🧡 인덱스의 특징



- 데이터베이스 안의 레코드를 처음부터 풀스캔하지 않고, **B+Tree로 구성된 구조에서 Index 파일 검색으로 속도를 향상시키는 기술**
- **Key와 Value 형태**로 이루어져있음

-  DBMS의 인덱스는 컬럼의 값을 주어진 순서대로 미리 정렬해서 보관

- 자료구조로 따지면 `SortedList`의 성질의 띄고 있음

  - <details> 
      <summary>SorteList는 뭘까..?🤔</summary> 
    <div markdown="1">
      - SortedList는 Hashtable과 ArrayList의 혼합형 <br/>
      - 내부 데이터는 Key와 value로 구성, Key의 오름차순으로 정렬되고 Key와 Index를 사용해서 검색 <br/> 
        - 새로운 값이 들어오면 키를 이진탐색해 적절한 인덱스를 찾고 그 곳에 키-값 쌍을 저장 <br/> 
      - SortedList의 가장 큰 특징은 내부적으로 정렬된 컬렉션을 유지하는 것 <br/>   
      - SortedList는 key와 Value로 이루어져 있기 때문에 IDictionary 인터페이스를 기본으로 사용 
      </div> 
    </details>

  - SortedList 는 매번 값을 넣을 때 마다 정렬 

    - 테이블에 인덱스 많으면 :  CUD 에 대한 처리 속도 ⬇︎ / 읽기 작업에 대한 속도 ⬆︎

  - 즉, 인덱스는 CUD(INSERT, UPDATE, DELETE) 에 대한 성능을 희생하고, 그 대신 데이터의 읽기(READ) 속도를 높이는 기능

  

``` 요약
💡 (참고!) 인덱스가 중요한 이유! 
	실제 DB 관련 작업을 할 때 대부분의 속도 저하는 바로 Select문!
	특히 조건 검색 Where절에서 발생하는데 가장 먼저 생각해 볼 수 있는 대안으로 
	Index를 생각할 수 있기도 하고, SQL 튜닝에서도 Index와 관련된 문제사항과 해결책이 많기 때문
```



<hr/>

#### 🧡인덱스의 생성과 동작 방식

![image-20220822221812902](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220822221812902.png)



1. 특정 컬럼에 인덱스를 생성 시 ->  해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장

2. 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등"의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수 있음. 

   ```
   // Mang이라는 이름을 업데이트 해주기 위해서는 Mang을 조회해야 한다.
   UPDATE USER SET NAME = 'MangKyu' WHERE NAME = 'Mang';
   ```

3. 만약 인덱스를 타게 되면 아래의 그림과 같이 인덱스를 타게 되고 먼저 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작을 하여 검색 속도 향상

<details> 
  <summary>🤔 옵티마이저란?</summary> 
<div markdown="1">
  - 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진<br/>
- 사용자가 구조화된 질의어(SQL)로 집합 요구 시, 이를 생성하는데 필요한 처리 경로는 DBMS에 내장된 옵티마이저가 자동으로 생성<br/>
  </div> 
  </details>



<hr/>

#### 🧡 Index의 관리

DBMS는 Index를 항상 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색 가능 

그렇기 때문에 Index가 적용된 칼럼에 INSERT, UPDATE, DELETE가 수행된다면 각각 다음과 같은 연산을 추가적으로 해줘야하며 그에 따른 오버헤드가 발생

- INSERT : 새로운 데이터에 대한 인덱스를 추가
- UDPATE : 기존의 인덱스를 **사용하지 않음** 처리하고, 갱신된 데이터에 대해 인덱스를 추가
- DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행



<hr/>

#### 🧡 Index의 장점과 단점

**장점 **

- 키값을 기초로 하여 테이블을 검색과 정렬 속도를 향상시킬 수 있음
- 질의나 보고서에서 그룹화 작업의 속도를 향상
- 인덱스를 사용하면 테이블 행의 고유성을 강화할 수 있음
- 테이블의 기본 키는 자동으로 인덱스 됨
- 여러 필드로 이루어진(다중필드) 인덱스를 사용하면 첫 필드 값이 같은 레코드도 구분할 수 있음 (참고로 액세스에서 다중필드 인덱스는 최대 10개의 필드 포함 가능)
- 전반적인 시스템의 부하를 줄일 수 있음



**단점**

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간 필요

- 어러 사용자 응용 프로금에서의 여러 사용자가 한 페이지를 동시에수정할 수 있는 병행성이 줄어즘

- 인덱스 된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제할 때 성능이 떨어짐

- 인덱스를 관리하기 위해 추가 작업 필요

- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생 할 수 있음

  > 만약 CUD가 빈번한 속성에 인덱스를 걸면 인덱스의 크기가 비대해져서 성능이 오히려 저하되는 역효과가 발생 할 수 있음

  > -> **UDPATE, DELETE는 기존 인덱스를 삭제하지 않고 "사용하지 않음" 처리**를 함

  > -> UDPATE, DELETE가 빈번하게 발생하면 실제 데이터는 10만건이지만 인덱스는 100만건이 넘어가는 사례가 발생할 수 있음



<hr/>

#### 🧡 Index를 사용할때와 안할때

인덱스 효율적 사용하려면 데이터 분포도는 최대한으로, **조건절에 호출 빈도는 자주 사용되는 칼럼을 인덱스로 생성**하는 것이 좋음

인덱스를 사용하는 것만큼이나 생성된 인덱스를 관리해주는 것도 중요 -> **사용되지 않는 인덱스는 바로 제거**해줘야함



##### **😍사용하면 좋은 경우**

1. 규모가 작지 않은 테이블

2. INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼
3. 외래키가 사용되는 컬럼

4. JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼

> **조건 검색 where 절의 효율성**
>
> 보통 Where절의 사용할 때, 특정 조건에 맞는 데이터를 찾기 위해 데이터를 처음부터 끝까지 다 비교하는데, 인덱스를 통해 데이터가 정렬되어 있으면 빠르게 찾기 가능

>  **정렬 Order by 절의 효율성**
>
> 인덱스를 사용하면 Order by에 의한 Sort과정을 피할 수 있음, 본래 Order by는 괴장히 부하가 많이 걸리는 작업이기 때문에 인덱스를 통해 이미 정렬되어 있으면 부하가 걸리지 않을 수 있음



##### **😡 사용을 피해야하는 경우**

1. Data 중복도가 높은 컬럼
2. DML이 자주 일어나는 컬럼



<hr/>

#### 🧡DML이 일어났을 때의 상황

<details> 
  <summary>DML 뭘까..?🤔</summary> 
<div markdown="1">
  DML(Data Manipu;ation Language) - 데이터 조작어<br/>
  정의된 데이터베이스에 입력된 레코드를 조회, 수정, 삭제하는 등의 역할을 하는 언어 <br/>
  쉽게 말하면, 테이블에 있는 행과 열을 조작하는 언어 <br/>
  데이터베이스 사용자가 질의어를 통하여 저장된 데이터를 실질적으로 처리하는데 사용하는 언어 <br/><br/> - SELECT : 데이터 조회<br/>
  - INSERT : 데이터 삽입<br/>
  - UPDATE : 데이터 수정<br/>
  - DELETE : 데이터 삭제<br/>
  </div> 
</details>

**① INSERT**

- Index split 현상이 발생할 수 있음
  - Index split : 인덱스의 Block들이 하나에서 두개로 나누어지는 현상
- 인덱스는 데이터가 순서대로 정렬되어있어야함 
- 기존 Blodck에 여유가 없을 때 그 블록에 새로운 데이터가 입력되어야하는 경우
- 오라클은 기존 블록 내용 중 일부를 새 블록에다가 기록한 후 기존 블록에 빈공간을 만들어서 새로운 데이터를 추가하게됨

>  ① Index split은 새로운 Block를 할당 받은 후, KEY를 옮기는 작업 수행
>
> ​      ->모든 수행 과정이 Redo에 기록되어 많은 양의 Redo를 유발 

>  ② Index split 작업 동안, 해당 Block의 Key 값이 변경되면 안되서 DML이 블로킹 된다. (대기 이벤트 발생)

##### 

**② DELETE**

- Table에서 데이터가 Delete 될 경우 -> 삭제 후 다른데이터가 그 공간 사용
- Index에서 데이터가 Delete 될 경우 -> 데이터 지워지지않고, 사용 안됨 표시 처리



 **③ UPDATE**

- 인덱스에는 UPDATE 개념이 없음
- Table에 UPDATE가 발생할 경우 
  - 인덱스에서는  Delete 가 먼저 발생한 후
  - 새로운 작업의 INSERT 작업이 발생한다.

​	=> Delete와 INSERT 두개 작업이 인덱스에 동시에 일어나 다른 DML보다 더 큰 부하를 주게됨





<hr/>

#  ❤️Index의 자료구조

 인덱스의 가장 대표적인 자료구조 헤시 테이블과 B+Tree가 있음



#### 🧡 해시테이블(Hash Table)

> 해시테이블
>
> - Key, Value로 데이터를 저장하는 자료구조 -> 빠른 데이터 검색이 필요할 때 유용
>
> - Key값을 이용해 고유한 Index를 생성해 그 Index에 저장된 값을 꺼내오는 구조
>
> - 해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원



그러나 해시테이블은 **실제로 인덱스에서 잘 사용하지 않음**

해시 테이블 기반의 DB 인텍스는 `(Key, Value)` =  `(컬럼의 값, 데이터의 위치)`로 구현하는데, **해시가 등호(=) 연산에 특화 되었기 때문!**

>  해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값 생성

>  부등호 연산(>,<)이 자주 사용되는 데이터베이스 검색에는 해시 테이블이 적합하지 않음

> 해시테이블 내에는 데이터들이 정렬되어 있지 않아 특정 기준보다 크고 작은 값을 빨리 찾기 어려움

> 예) '나는'으로 시작되는 모든 데이터 검색을 하기 위한 쿼리문은 인덱스의 혜택을 전혀 못받음 -> 그래서 데이터 베이스에서는 B+Tree가 일반적으로 사용됨

![image-20220822224502614](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220822224502614.png)



<hr/>

#### 🧡 B+Tree

> 기존의 B-tree는 어느 한 데이터의 검색은 효율적이지만, 
>
> 모든 데이터를 한번 순회하는데에 트리의 모든 노드를 방문해야 함으로 비효율적, 
>
> 이러한 B-Tree의 단점을 개선 시킨 자료구조가 B+Tree

 B+Tree는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스!

구조는 **`Root Node(기준)`**/**`Branch Node(중간)`**/**`Leaf Node(말단)`**으로 구성되며 계층적 구조를 가지고 있다.



**B+Tree 특징**

- **Leaf Node(데이터노드)만 인덱스(Key)와 함께 데이터(Value)를 가지고 있고**, 나머지 Root Node와 Branch Node는 데이터를 위한 인덱스(Key)만을 갖음
- Leaf Node에만 데이터를 저장하고 Leaf Node는 서로 LinkedList로 연결되어 선형 시간이 소모되어 시간 효율이 올라감
- Root Node에서 경로를 확인 후, 그에 알맞는 Node로 이동하여 최종적으로 원하는 데이터가 있는 Leaf Node에 도달
- B+Tree는 오직 leaf node에만 데이터가 저장되기 때문에 중간 node에서 key를 올바르게 찾아가기 위해서 key가 중복 될 수 있음
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.



![image-20220823084858838](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220823084858838.png)



**B+Tree의 장점**

- 리프노드에만 데이터를 저장해서 메모리를 더 확보 가능 -> 하나의 Node에 더 많은 포인터를 가질 수 있어 트리의 높이가 더 낮아져 검색속도 ⬆︎
- Full scan을 하는 경우, B+Tree는 리프노드에만 데이터가 저장되어 있고, 리프노드끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모됨 반면 B-Tree는 모든 노드를 확인해함



**B+Tree의 단점**

- B+Tree의 경우 반드시 특정 Key에 접근하기 위해서 리프 노드까지 가야하는 단점이 있음





<hr>

출처

https://github.com/NKLCWDT/cs/blob/main/Database/Index%2C%20Hint.md

https://mangkyu.tistory.com/96

https://rebro.kr/167

https://lalwr.blogspot.com/2016/02/db-index.html

https://velog.io/@alicesykim95/DB-%EC%9D%B8%EB%8D%B1%EC%8A%A4Index%EB%9E%80

https://coding-factory.tistory.com/743

