# 해시(Hash) 자료구조
- 키(Key)와 값(Value) 쌍으로 이루어진 데이터 구조.
- 해시 구조에서는 Key를 이용하여 데이터(value)를 빠르게 찾을 수 있는 장점이 있다.  

## 용어
- **키 (Key)** : 해시 함수의 input 이 되는 고유한 값. 키(key)는 해시함수(hash function)를 통해 해시(hash)로 변경되어 value 값과 매칭되어 저장소에 저장된다.  
- **해시 (Hash)** : 임의의 값을 고정 길이로 변환하는 것. *key 값 그대로 저장소에 저장되게 되면 다양한 길이의 저장소를 구성해야하기 때문에 효율성을 위해 일관적으로 해시(hash)로 변경하여 저장함으로써 공간 효율성을 최적화한다.*. 
- **해시 테이블 (Hash Table)** : Key 값의 연산에 의해 직접 접근이 가능한 데이터 구조.  
- **버킷 (Bucket), 슬롯 (Slot)** : Hash table 에서 하나의 데이터가 저장되는 공간.  
- **해시 함수 (Hashing Function)** : Key 값에 대해 연산을 통해 데이터(value) 위치를 찾는 함수.  
- **Hash Value, Hask Address** : Key 값을 이용해 Hashing function 을 연산하여 Value 를 알아낼 수 있고, 이를 기반으로 Hash table 에서 해당 key 에 대한 데이터 위치(주소)를 찾을 수 있음.   



<img src="https://user-images.githubusercontent.com/37866609/183882590-18ca84f3-0574-43b4-8777-75d161815655.png" width="700">  


## 해시 함수
- 데이터의 효율적 관리를 목적으로 임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 함수.
- Key를 Hash로 바꿔 메모리를 효율적으로 관리하도록 함. 빠른 연산 속도가 특징.
- 매핑 전 원래 데이터의 값 : **키(Key)**
매핑 후 데이터의 값 :  **해시값(Hashvalue)**
매핑하는 과정 : **해싱(Hashing)**. 


## 해시테이블(Hashtable)
- (Key, Value)로 데이터를 저장하는 자료구조.
- 각각의 Key에 해시함수를 사용 → key를 해시값으로 매핑 → 배열의 고유한 Index or 주소를 생성 → 데이터의 값(Value)를 key와 함께 저장.
- Key값으로 데이터를 찾을 때 해시 함수를 1번만 수행하면 되기 때문에 저장/삭제/조회시 매우 빠름.
- 해시함수는 해쉬값의 개수보다 대개 많은 키값을 해쉬값으로 변환(many-to-one 대응)하기 때문에 해시함수가 서로 다른 두 개의 키에 대해 동일한 해시값을 내는 해시충돌(collision)이 발생하게 됨.


## 해시충돌 해결  
### Chaining
버켓 내에 연결 리스트를 할당하여, 버켓에 데이터를 삽입하다가 해시 충돌이 발생하면 연결 리스트로 데이터들을 연결하는 방식.

- 장점
    - 한정된 저장소(Bucket)을 효율적으로 사용할 수 있다.
    - 해시 함수를 선택할 때 hash collision을 걱정하지 않아도 된다.
    - 상대적으로 적은 메모리를 사용한다. (미리 공간을 잡을 필요가 없다.)
- 단점
    - 한 Hash에 자료들이 계속 연결된다면 쏠림 현상으로 검색 효율을 낮출 수 있다.
    - 외부 저장 공간을 사용  


### 개방 주소법(Open Addressing)  
체이닝의 경우 버켓이 꽉 차더라도 연결 리스트로 계속 늘려가기에 데이터의 주소값은 바뀌지 않는다.(Closed Addressing)

하지만 개방 주소법은 충돌이 일어나면 다른 버켓에 데이터를 삽입하는 방식이다. 개방 주소법은 대표적으로 3가지가 있다.

1. 선형 탐색(Linear Probing) : 해시충돌 시 다음 버켓, 혹은 몇개를 건너뛰어 데이터를 삽입한다.
2. 제곱 탐색(Quadratic Probing) : 해시충돌 시 제곱만큼 건너뛴 버켓에 데이터를 삽입한다.
3. 이중 해시(Double Hashing) : 해시충돌 시 다른 해시함수를 한번 더 적용한 결과를 이용한다.
- 장점
    - 추가 저장 공간이 필요 없다.
- 단점
    - 해시 함수의 성능에 전체 해시테이블의 성능이 좌지우지된다.
    - 데이터 길이가 늘어나면 그에 해당하는 저장소를 마련해야한다.  


## 해시의 장점 
1. 적은 리소스로 많은 데이터를 효율적으로 관리. 
해시함수로 하드디스크나 클라우드에 존재하는 무한에 가까운 데이터(key)들을 유한한 개수의 해시값으로 매핑함으로써 작은 크기의 캐쉬 메모리로도 프로세스를 관리할 수 있음.
2. index에 해시값을 사용함으로써 모든 데이터를 살피지 않아도 검색과 삽입/삭제를 빠르게 수행할 수 있음. 
3. 해시함수는 언제나 동일한 해시값을 리턴하고, 해당 인덱스만 알면 해시테이블의 크기에 상관없이 데이터에 빠르게 접근할 수 있으며, 인덱스 계산이 간단한 함수로 작동하기 때문에 매우 효율적. 
4. 해시는 보안 분야에서도 널리 사용. 키와 해시값 사이에 직접적인 연관이 없기 때문에 해시값만 가지고는 키를 온전히 복원하기 어렵기 때문. 값을 해시로 변환하면, 기존의 값을 알아볼 수 없다.
5. 해시함수는 길이가 서로 다른 입력데이터에 대해 일정한 길이의 출력을 만들 수 있어서 ‘데이터 축약’ 기능도 수행할 수 있음.  


## Swift에서
- 스위프트에서 `Dictionary의 키와 Set`로 사용되기 위해서는 해당 타입은 반드시 `Hashable 프로토콜`을 준수해야 함 ⇒ 그래서 String, Int, Boolean 타입과 같은 `Standard Library`에 속한 많은 타입들은 Hashable 프로토콜을 준수함. 사용자가 만든 타입도 Hashable 프로토콜을 준수한다면 딕셔너리의 키나 세트로 사용이 가능.
[https://baked-corn.tistory.com/123](https://baked-corn.tistory.com/123)
- 사용자 정의 타입을 딕셔너리의 키나 세트에서 사용하기 위해서는 `Hashable` 프로토콜을 준수해야 함. `Hashable` 프로토콜은 `Equatable` 프로토콜을 상속 받음. 그렇기 때문에 이 두 프로토콜의 요구 사항을 모두 충족시켜야 함. 
사용자 정의 타입은 선언부에 `Hashable`을 작성해주어 해당 프로토콜을 준수한다 명시하고 
만일 해당 타입이 **구조체**라면 **저장 프로퍼티의 타입**들이 모두 Hashable 프로토콜을 준수해야 하고 
**열거형**이라면 **연관 값의 타입**이 Hashable 프로토콜을 준수해야 합니다.
- **Hashable 프로토콜을 준수하는 모든 타입의 인스턴스는 hashValue 라는 정수형 프로퍼티를 갖고 있으며 이 값은 각각의 인스턴스를 식별하는 값이 됨. 그렇기 때문에 반드시 하나만 존재해야 하는 딕셔너리의 키값이나 중복된 값은 허용하지 않는 자료구조인 세트에 들어가는 값들은 Hashable해야 한다는 것.**



## 출처
https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/   
https://preamtree.tistory.com/20  
https://dean30.tistory.com/113
