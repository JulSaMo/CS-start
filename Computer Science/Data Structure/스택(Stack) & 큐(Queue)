# 스택(Stack) & 큐(Queue)

![스택.png](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8(Stack)%20&%20%E1%84%8F%E1%85%B2(Queue)%2029549d4bdd81421594e557e1c047af45/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%2590%25E1%2585%25A2%25E1%2586%25A8.png)

# 스택

- 데이터를 임시 저장하는 기본 자료구조.
- 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고, top으로 정한 곳을 통해서만 접근해 자료를 넣고 뺄 수 있다.
- 데이터가 순서대로 쌓이며 가장 마지막에 삽입된 데이터가 가장 먼저 삭제되는 LIFO(Last In First Out) 구조다. 
ex) 식당에 순서대로 쌓인 접시처럼. 접시가 필요하면 제일 위에 있는 접시부터 사용하며 가장 아래 있는 접시는 마지막에 사용된다.
- 스택이 완전히 꽉 찼을 때 `Overflow` 상태라고 하며 완전히 비어 있으면 `Underflow` 상태라고 한다.

## 스택의 연산

![pushpop.png](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8(Stack)%20&%20%E1%84%8F%E1%85%B2(Queue)%2029549d4bdd81421594e557e1c047af45/pushpop.png)

- push(data): 스택 맨 위에 데이터를 삽입한다.
    - **1 단계** - 스택이 가득 찼는 지 확인한다.
    - **2 단계** - 스택이 가득 차면 오류가 발생하고 종료된다.
    - **3 단계** - 스택이 가득 **차지** 않으면 Top을 증가시킨다.
    - **4 단계** - Top이 가리키는 스택 위치에 데이터를 추가한다.
- pop(): 스택 맨 위에 있는 데이터를 제거한다.
    - **1 단계** - 스택이 비어 있는지 확인한다.
    - **2 단계** - 스택이 비어 있으면 오류가 발생하고 종료된다.
    - **3 단계** - 스택이 비어 있지 않으면 Top이 가리키는 데이터를 제거한다.
    - **4 단계** - Top 값을 감소시킨다.
    - **5 단계** - 성공을 반환한다.
- peek(): 스택의 가장 위에 있는 항목을 반환한다.(가장 상단에 있는 데이터를 삭제하지 않고 확인만 하고 싶을 때)
- isEmpty(): 스택이 비어 있을 때에 true를 반환한다.
- isFull() - 스택이 가득 차 있을 때에 true를 반환한다.
- getSize - 스택에 있는 요소 수를 반환한다.

## 스택의 구현

- 배열 사용
    
    ![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8(Stack)%20&%20%E1%84%8F%E1%85%B2(Queue)%2029549d4bdd81421594e557e1c047af45/Untitled.png)
    
    - 장점 : 구현하기 쉬움. 원하는 데이터의 접근 속도가 빠름. ex) 만약 내가 원하는 데이터가 배열의 3번째 위치에 있으면 arr[2]를 사용한다면 한번에 접근이 가능하기 때문.
    - 단점: 데이터 최대 개수를 미리 정해야 한다. 데이터의 삽입과 삭제에 있어 매우 비효율적 ⇒ 특정 위치에 삽입하기 위해 다른 데이터들을 다 한칸씩 뒤로 밀어야 하기 때문.
    - 데이터 양이 많지만 삽입/삭제가 거의 없고, 데이터의 접근이 빈번히 이뤄질 때 유리!!
- 연결 리스트 사용
    
    ![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8(Stack)%20&%20%E1%84%8F%E1%85%B2(Queue)%2029549d4bdd81421594e557e1c047af45/Untitled%201.png)
    
    - 장점 : 데이터의 최대 개수가 한정되어있지 않음. 데이터의 삽입 삭제가 용이 ⇒ 다음 위치에 해당하는 노드의 주소값만 바꿔주면 되기 때문.
    - 단점 : 한번에 원하는 데이터의 접근이 불가능 ⇒ 연결되어 있는 링크를 따라 차근차근 하나씩 확인하며 데이터를 찾아야 하기 때문.
    - 삽입/삭제가 빈번히 이뤄지고, 데이터의 접근이 거의 없을 때 유리!!

## 스택의 활용

- 웹 브라우저 방문기록(뒤로 가기) : 가장 나중에 열린 페이지부터 다시 보여준다.
- 실행 취소(undo) : 가장 나중에 실행된 것부터 실행을 취소한다.
- 괄호의 짝 검사 : 괄호의 짝, 괄호의 순서 검사.
- 역순 문자열 만들기 : 가장 나중에 입력된 문자부터 출력한다.
- 수식의 괄호 검사 : 연산자 우선순위 표현을 위한 괄호검사.

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8(Stack)%20&%20%E1%84%8F%E1%85%B2(Queue)%2029549d4bdd81421594e557e1c047af45/Untitled%202.png)

# 큐(Queue)

- 스택과 다르게 먼저 들어오는 것이 먼저 나가는 FIFO(First In First Out)의 구조를 가지고 있다. 
ex) 은행 번호표 : 먼저 온 손님이 먼저 서비스를 받는 것처럼.
- 정해진 한 곳(Top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에선 삽입 작업이, 다른 쪽 끝에선 꺼내는 작업이 양쪽으로 이루어진다.
- 가득 찬 큐에 요소를 추가하려고 할 때 `Overflow` 가 발생하고, 빈 큐에서 요소를 꺼내려고 할 때  `Underflow` 가 발생한다.

## 큐의 연산

- front : 큐의 가장 첫 원소. 출력 연산만 이루어지는 곳.
- rear : 큐의 가장 끝 원소. 삽입 연산만 이루어지는 곳.
- dequeue() : 큐의 맨 앞(front)의 요소를 꺼내는 연산. **front + 1**을 하고 그 자리에 있던 요소를 출력한다.
- enqueue() : 큐의 맨 끝(rear)에 요소를 추가하는 연산. **rear + 1**을 하고 그 자리에 요소를 추가한다.
- isfull() : 큐가 가득 찼는지 확인. **rear = n - 1**, 즉 rear가 마지막 인덱스를 가리키면 꽉 찬 것이다.
- isempty() : 큐가 비어 있는지 확인. **front = rear**이면 큐가 비었다고 판단한다.
- peek() : front에 위치한 데이터를 반환.

## 큐의 특징

- 큐는 들어올 때 rear로 들어오지만, 나올 때는 front부터 빠지는 특성.
- 접근방법은 가장 첫 원소와 끝 원소로만 가능.

## 큐의 종류

### 선형 큐

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8(Stack)%20&%20%E1%84%8F%E1%85%B2(Queue)%2029549d4bdd81421594e557e1c047af45/Untitled%203.png)

- 배열을 선형으로 사용하여 구현된 큐.
- 문제점
    - 크기가 제한되어 있고, 이미 사용한 영역인 front의 앞부분에 대해서 다시 활용을 못하기 때문에 메모리를 낭비한다.
    - rear와 front의 값(인덱스)이 자꾸 증가하기만 해서 결국 배열의 앞부분이 비어있더라도 큐는 꽉 찼다고 인식하기 때문에.
    - 이런 공간 낭비를 배열의 요소들의 인덱스를 하나씩 당겨주는 방법으로 해결할 수 있지만, 원형 큐로 구현하면 더 쉽게 해결할 수 있다.

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8(Stack)%20&%20%E1%84%8F%E1%85%B2(Queue)%2029549d4bdd81421594e557e1c047af45/Untitled%204.png)

![Untitled](%E1%84%89%E1%85%B3%E1%84%90%E1%85%A2%E1%86%A8(Stack)%20&%20%E1%84%8F%E1%85%B2(Queue)%2029549d4bdd81421594e557e1c047af45/Untitled%205.png)

### 원형 큐

- 일반적으로, 배열을 사용한 큐라면 위 상황에서 자료를 더 push하고 싶다면, 456을 앞으로 당기거나 배열의 크기를 늘리는 수 밖에 없다. 하지만 앞으로 당기는 것도 비용이 발생하고, 배열의 크기를 늘리는 일 또한 공간적 낭비가 심하다. 그래서 생각해낸 방법이 앞에 비워진 공간을 활용하는 방법이다.
- front와 rear가 Inqueue와 dequeue를 반복해 증가하다가 배열의 끝 인덱스에서 증가하면은 인덱스 0을 가리키도록 하면 된다. 이는 나머지 연산으로 쉽게 구현할 수 있다.⇒ (index + 1) % size.
- 배열의 포화상태 여부를 판단하기 위하여 배열의 1칸은 비워둔다. (rear+1)%arraysize == front 라면 배열이 포화상태인걸로 판단하여 데이터 삽입이 이루어지지 않게 된다.
- rear==front 조건이라면 배열이 공백상태인걸로 판단하여 Dequeue가 실행되지 않는다.

### 연결리스트 큐

- 배열로 구현한 큐의 단점은 크기를 미리 정해야 하고, 그 크기를 넘어서면 error가 발생한다는 것이다. 반면 연결리스트로 구현하면 큐의 크기(size)를 미리 정할 필요가 없다.
- 배열 대신 연결리스트로 원소들을 관리
    - 큐의 원소 : 단순 연결 리스트의 노드
    - 큐의 원소의 순서 : 노드의 링크 포인터로 연결
    - 변수 front : 첫 번째 노드를 가리키는 포인터 변수 (초기 null)
    - 변수 rear : 마지막 노드를 가리키는 포인터 변수 (초기 null)
- 주요 특징
    - 배열을 이용할 경우에 비해, 크기 제한이 거의 없음
    - 동적 메모리 할당으로 기억장소 사용에 제한이 적음
    - 큐에서 enQueue 및 deQueue 방법은 단순연결리스트의 삽입/삭제 방법과 거의 동일
    - 배열의 인덱스 대신 포인터 사용에 따른 부담은 존재
- 큐의 상태
    - 초기 상태 : front = rear = null
    - 공백 상태 : front = rear = null
    - 초기 상태와 공백 상태가 동일!
    - 큐가 꽉 차서 더 이상의 원소를 추가하지 못하는 경우는 거의 없음

## 큐의 활용

- 프린터의 출력 처리
- 은행 업무
- 콜센터 고객 대기시간
- 프로세스 관리
- 너비 우선 탐색(BFS, Breadth-First Search) 구현
- 캐시(Cache) 구현
- 컴퓨터 버퍼에서 주로 사용, 마구 입력이 되었으나 처리를 하지 못할 때, 버퍼(큐)를 만들어 대기 시킨다. 먼저 들어온 입력먼저 처리

⇒ 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용

## 출처

### Stack

[[자료구조] 스택 (Stack)](https://yoongrammer.tistory.com/45)

[[알고리즘] 2.1. 자료구조 : 스택(Stack) 이해하기](https://monsieursongsong.tistory.com/4)

[[자료구조] 스택(Stack)](https://propercoding.tistory.com/17)

### Queue

[[자료구조] 스택 (STACK), 큐(QUEUE) 개념/비교 /활용 예시](https://devuna.tistory.com/22)

[[자료구조] 큐 자료구조의 구현](https://velog.io/@dongchyeon/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%81%90-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EA%B5%AC%ED%98%84)

[03 원형 큐 (Circular Queue) 자료 구조](https://lktprogrammer.tistory.com/59)

[](https://monsieursongsong.tistory.com/5?category=754667)

[[자료구조] 스택(Stack), 큐(Queue)](https://currygamedev.tistory.com/17)

[[자료구조] 큐 Queue / 연결리스트를 이용한 큐의 구현](https://ppomelo.tistory.com/58)
