# 힙(Heap)
힙은 우선 순위 큐를 위하여 만들어진 자료구조다. 

## 우선 순위 큐
- 우선순위의 개념을 큐에 도입한 자료 구조.
- 데이터들이 우선순위를 가지고 있고, 들어온 순서와 상관없이 우선순위가 가장 크거나 작은 데이터가 먼저 나간다.
- 만약 두 원소가 같은 우선순위를 가진다면 그들은 큐에서 그들의 순서에 의해 처리된다.
    - *스택* - 원소들은 후입선출 순으로 처리된다.
    - *큐* - 원소들은 선입선출 순으로 처리된다.
- 우선순위 큐는 배열, 연결리스트, 힙으로 구현이 가능하다. 이 중에서 힙(heap)으로 구현하는 것이 가장 효율적이다.
: 가장 크거나 작은 자료를 찾는데 효율적인 자료구조라서.




## 힙이란?
- 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.
    - 완전 이진 트리 : 마지막을 제외한 모든 노드에서 자식들이 꽉 채워진 이진트리.
- 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.
- 힙은 일종의 반정렬 상태(느슨한 정렬 상태)를 유지한다.
: 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도
간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다.
- 힙 트리에서는 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)


## 힙의 종류

- 최대 힙(max heap)
: 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
key(부모 노드) >= key(자식 노드)
- 최소 힙(min heap)
: 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
key(부모 노드) <= key(자식 노드)
- 키값의 대소관계는 오로지 부모노드와 자식노드 간에만 성립하며, 특히 형제 사이에는 대소관계가 정해지지 않는다.  

<img src="https://user-images.githubusercontent.com/37866609/183874821-6323fbaa-b53a-4e3f-8764-da6cd38c4615.png" width="700">  


## 구현
- 힙을 저장하는 표준적인 자료구조는 배열 이다.
- 구현을 쉽게 하기 위하여 배열의 첫 번째 인덱스인 0은 사용되지 않는다.
- 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않는다. 예를 들어 루트 노드의 오른쪽 노드의 번호는 항상 3이다.
- 힙에서의 부모 노드와 자식 노드의 관계
    - 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
    - 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
    - 부모의 인덱스 = (자식의 인덱스) / 2   

<img src="https://user-images.githubusercontent.com/37866609/183874990-ed5f93dc-77e8-4043-9de3-e9baa778fcd2.png" width="700">  


## 삽입과 삭제로 깨진 힙을 재구조화하기(heapify)
최대힙의 부모노드는 항상 자식노드의 값보다 크다는 조건을 가지고 있다. 하지만 힙에서 **삽입** 또는 **삭제**가 일어나게 되면 경우에 따라 **최대힙의 조건이 깨질 수 있다.** 이러한 경우에 최대힙의 조건을 만족할 수 있게 노드들의 위치를 바꿔가며 힙을 **재구조화(heapify)** 해주어야 한다.  

삽입과 삭제의 경우 모두 **연산 자체는 *O*(1)**로 작동하지만 heapify의 과정을 거치기 때문에 ***O*(*logn*)의 시간복잡도**를 가지게 된다.

### 삽입
1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입한다.
2. 새로운 노드를 부모 노드들과 교환해서 힙의 성질을 만족시킨다.  

<img src="https://user-images.githubusercontent.com/37866609/183875204-a465f7df-aa9c-427f-a278-3b613790668c.png" width="700">   

### 삭제
1. 최대 힙에서 최댓값은 루트 노드이므로 루트 노드가 삭제된다. 
: 최대 힙(max heap)에서 삭제 연산은 최댓값을 가진 요소를 삭제하는 것이다.
2. 삭제된 루트 노드에는 힙의 마지막 노드를 가져온다.
3. 힙을 재구성한다. 

<img src="https://user-images.githubusercontent.com/37866609/183875400-ed3857c2-e333-4c6a-a717-80f5392ac0ce.png" width="700">



## 활용 예

- 스택과 다르게 먼저 들어오는 것이 먼저 나가는 FIFO(First In First Out)의 구조를 가지고 있다. 
ex) 은행 번호표 : 먼저 온 손님이 먼저 서비스를 받는 것처럼.
- 정해진 한 곳(Top)을 통해서 삽입, 삭제가 이루어지는 스택과 달리 큐는 한쪽 끝에선 삽입 작업이, 다른 쪽 끝에선 꺼내는 작업이 양쪽으로 이루어진다.
- 가득 찬 큐에 요소를 추가하려고 할 때 `Overflow` 가 발생하고, 빈 큐에서 요소를 꺼내려고 할 때  `Underflow` 가 발생한다.


## 큐의 연산
- 우선순위 큐를 구현하는데 사용한다.
- 게임엔진에서 각 액터의 우선순위를 정한다.
- 서버에서 많은 트래픽을 처리할 때 우선 처리해야 할 트래픽을 정한다.
- 시뮬레이션 시스템
- 네트워크 트래픽 제어
- 운영 체제에서의 작업 스케쥴링 (우선 순위가 높은 일을 바로 조회할 수 있다.)
- 수치 해석적인 계산



## 출처
https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html   
https://ko.wikipedia.org/wiki/%ED%9E%99_(%EC%9E%90%EB%A3%8C_%EA%B5%AC%EC%A1%B0)   
https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%9E%99Heap
