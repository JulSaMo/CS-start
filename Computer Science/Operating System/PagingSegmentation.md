# 페이징(Paging)
#### 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식
  - 페이지: 고정 사이즈의 가상 메모리 내 프로세스 조각
  - 프레임: 페이지 크기와 같은 주 기억 장치의 메모리 조각
  
#### 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다.

## 페이징 테이블(Paging Table)
![페이징 테이블](https://user-images.githubusercontent.com/66079439/188811707-399cc22b-1302-414f-8aa3-608a77205c5f.png)
  - 위 사진은 페이징 테이블의 매핑을 나타낸다.
  - 앞서 봤듯이, 물리 메모리는 고정 크기의 프레임으로, 가상 메미로는 고정크기의 페이지로 분리되어 있다.
  - 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장된다.
  
#### 즉, 모든 프로세스는 하나의 페이징 테이블을 가지고 있으며, 여기에는 메인 메모리에 적재되어 있는 페이지 번호와 해당 페이지가 위치한 메인 메모리의 시작 주소가 있다. 이를 통해 하나의 프로세스를 나눈 가상 메모리 페이지들이 각각 실제 메인 메모리의 어디 프레임에 적재되어 있는지 알아낼 수 있다.

![PMT](https://user-images.githubusercontent.com/66079439/188812027-3ee41eb1-849b-425b-9e8c-8b3f4d4b8dff.png)
#### 위 PMT(Page Mapping Table, 페이징 테이블)에는 P1 프로세스의 0번째 페이지가 메인 메모리의 5번째 프레임에 있는 것을 알 수 있다.

## 논리 주소와 페이지 테이블
#### 앞서 메모리 관리 장치(MMU, Memory Management Unit)는 가상 주소 (논리 주소)를 이용해 실제 데이터가 담겨 있는 주소로 변환해준다고 하였다.
![논리주소](https://user-images.githubusercontent.com/66079439/188813249-f67065f0-1f54-42b6-99f1-21c18ceb99d1.png)

#### 논리 주소(Logical Address)는 <page, offset> 과 같은 형태로 구성되는데, 이를 이용해 물리 주소로 변환해 주는 것이다.

![논리주소2](https://user-images.githubusercontent.com/66079439/188813361-0be93bd6-fa19-4080-b0a5-b73ae6123338.png)

#### 가상 주소를 물리 주소로 변환하는 전체 과정이다.

## 페이징의 장단점
  - 장점
    - 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고
    - 물리 메모리의 남는 프레임에 적절히 배치되기 때문에 외부 단편화가 생기지 않는다.
 
 - 단점
    - 내부 단편화 문제가 발생할 수 있다.
    - 페이지 단위를 작게하면 해결할 수 있지만, 페이지 매핑 과정이 복잡해져 오히려 비효율적이다.
    
    ![페이징](https://user-images.githubusercontent.com/66079439/188813718-4507a72c-662a-4f54-8e49-a80f2ff66e5f.png)

# 세그멘테이션(Segmentation)
#### 세그먼트는 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것을 의미한다.
#### 세그먼테이션은 프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해서 메모리에 적재한느 방식이다.
  - 돼지를 도축할 때, 페이징은 돼지를 같은 크기로 잘라서 보관하는 것이라면,
  - 세그멘테이션은 부위별로 잘라서 보관한다고 이해하면 된다.
  
#### 이렇듯 세그먼트는 의미가 같지 않는 논리적 내용을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않다.

## 세그먼트 테이블
#### 분할 방식을 제외하면, 페이징과 세그멘테이션이 동일하기 때문에 매핑 테이블의 동작 방식도 동일하다. 다만, 논리 주소의 앞 비트들은 페이징 번호가 아니라 세그먼트 번호가 될 것이다. 즉, <segment, offset> 형태로 구성되며, 세그먼트 번호를 통해 세그먼트의 기준(세그먼트의 시작 물리 주소)와 한계(세그먼트의 길이)를 파악할 수 있다.

## 세그멘테이션의 장단점
  - 장점
    - 내부 단편화 문제가 해소된다.
    - 보호와 공유 기능을 수행할 수 있다.
    - 프로그램의 중요한 부분과 중요하지 않은 부분을 분리하여 저장할 수 있고,
    - 같은 코드 영역은 한 번에 저장할 수 있다.
    
  - 단점
    - 외부 단편화 문제가 생길 수 있다.
    
# 페이징과 세그멘테이션
## 단순페이지
  - 각 프로세스는 프레임과 같은 길이를 가진 균등 페이지로 나뉜다.
  - 외부 단편화가 생기지 않는다.
  - 내부 단편화가 존재할 수 있다.
  
## 단순 세그멘테이션
  - 각 프로세스는 여러 세그먼트로 나뉜다.
  - 내부 단편화가 생기지 않는다.
  - 메모리 효율을 개선한다.
  - 동적 분할을 통한 오버헤드가 감소한다.
  - 외부 단편화가 존재할 수 있다.

## 가상 메모리 페이징
  - 단순 페이징과 비교해 프로세스 페이지 전부를 로드할 필요가 없다.
  - 필요한 페이지가 있으면 나중에 자동으로 불러들인다.
  - 외부 단편화가 생기지 않는다.
  - 복잡한 메모리 관리로 오버헤드가 발생할 수 있다.
  
## 가상 메모리 세그멘테이션
  - 필요하지 않은 세그먼트들은 로드되지 않는다.
  - 필요한 세그먼트가 있을 때 나중에 자동으로 불러 들인다.
  - 내부 단편화가 생기지 않는다.
  - 복잡한 메모리 관리로 오버헤드가 발생할 수 있다.
  

