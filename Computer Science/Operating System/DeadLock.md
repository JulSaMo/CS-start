// 2022.09.07 루키


## **데드락 (DeadLock, 교착 상태)**

**데드락이란??**
두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태 

무한히 다음 자원을 기다리게 되는 상태를 말한다.

- 자원이란?

시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.

(마치, 외나무 다리의 양 끝에서 서로가 비켜주기를 기다리고만 있는 것과 같다.)

## 데드락이 발생하는 경우
<img width="720" alt="image" src="https://user-images.githubusercontent.com/103009135/188778000-326073d1-02f0-4c96-9ac3-24b9ffa65808.png">


프로세스1과 2가 자원1, 2를 모두 얻어야 한다고 가정해보자

1. 프로세스1이 자원1을 사용하고 있고 그 다음 자원2를 가져와야 다음 작업을 할 수 있음
2. 프로세스2는 자원2를 사용하고 있는데 그 다음 자원1이 필요한 상황임!! 

그러면 현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠지게 된다. 

이러한 상황을 바로 **DeadLock 이라고 한다!** 

### **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%83%E1%85%A6%E1%84%83%E1%85%B3%E1%84%85%E1%85%A1%E1%86%A8-deadlock-%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%A2%E1%86%BC-%E1%84%8C%E1%85%A9%E1%84%80%E1%85%A5%E1%86%AB)*데드락(DeadLock) 발생 조건***

[https://kukuta.tistory.com/281](https://kukuta.tistory.com/281) 이 블로그 글이 맛집입니다. 참고하시면 좋아요! 

데드락은 다음 4가지 모두 성립해야 발생하는 문제라고 합니다/ 

(하나라도 성립하지 않으면 데드락 문제 해결 가능)

1. **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%89%E1%85%A1%E1%86%BC%E1%84%92%E1%85%A9-%E1%84%87%E1%85%A2%E1%84%8C%E1%85%A6-mutual-exclusion)상호 배제(Mutual exclusion)**
    
    자원은 한번에 한 프로세스만 사용할 수 있어야함.
    →이러한 특성은 다른 프로세스가 대기 상태에 빠지게 합니다.
    
2. **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%8C%E1%85%A5%E1%86%B7%E1%84%8B%E1%85%B2-%E1%84%83%E1%85%A2%E1%84%80%E1%85%B5-hold-and-wait)점유 대기(Hold and wait)**
    
    최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함.
    →상호 배제 특성을 가져도, 대기하는 프로세스가 없다면 당연히 데드락은 발생하지 않습니다. 
    
3. **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%87%E1%85%B5%E1%84%89%E1%85%A5%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B7-no-preemption)비선점(No preemption)**
    
    다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
    
    → 선점 가능하다면 당연히 걍 뺏어오면 되겟죠?
    
4. **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%89%E1%85%AE%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB-%E1%84%83%E1%85%A2%E1%84%80%E1%85%B5-circular-wait)순환 대기(Circular wait)**
    
    프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함
    
    → 쉽게 말해서 상대방이 필요한 자원을 점유한 상태로, 상대방이 가지고 있는 자원을 요청하고 있는 상태입니다. 
    

### **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%83%E1%85%A6%E1%84%83%E1%85%B3%E1%84%85%E1%85%A1%E1%86%A8-deadlock-%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5)*데드락(DeadLock) 처리***

데드락을 처리하는 방법에는 크게 방지와 회피 방식이 있다고 합니다. 

### **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%80%E1%85%AD%E1%84%8E%E1%85%A1%E1%86%A8-%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%8B%E1%85%A8%E1%84%87%E1%85%A1%E1%86%BC-%E1%84%92%E1%85%AC%E1%84%91%E1%85%B5)교착 상태를 방지 & 회피**

1. **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%8B%E1%85%A8%E1%84%87%E1%85%A1%E1%86%BC-prevention)방지(prevention)**
    
    교착 상태 발생 조건 중 하나를 제거하면서 해결한다 
    
    - 상호배제 방지 →  자원을 공유 가능하도록 만들면 됩니다. (ex. READ ONLY 파일)
    (swift에서 GET only property도 이런 의도로 만들어놓았지 않나 싶네요!)
    
    - 점유 대기 방지 : 프로세스 실행전 모든 자원을 할당하거나 동시에 점유할 수 있는 자원을 제한한다. 
    (그러면 다른 자원을 획득하기 위해 가지고 있는 자원을 해제해야하기 떄문에 대기 상태를 막을 수 있다! )
    - 비선점 방지 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
    CPU 스케줄링을 선점 방식으로 하면 된다는 말 같습니다.
    - 순환대기 방지 : 자원에 고유번호 할당 후 순서대로 자원 요구.
    순환대기는 프로세스가 점유하는 자원이 서로에게 필요할 때 발생합니다. 그러니 프로세스들의 획득하는 자원 순서를 정해주면 이를 방지할 수 있는 것입니다.
2. **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%92%E1%85%AC%E1%84%91%E1%85%B5-avoidance)회피(avoidance)** 

 회피는 교착 상태 발생 시 피해나가는 방법입니다. 교착 발생 보다 예방이 더 낫지 않냐! 라는 의문이 들 수도 있겠는데요. 데드락 방지를 위한 설계에는 당장 사용하지 않는 자원을 점유하거나, 이미 할당된 자원을 반납하는 등의 흐름으로 작업 수행 시 성능을 낮춘다는 단점이 있다고 합니다. 
 그러니 성능을 올리기 위해서 최대한 제약 사항을 없애고, 각 상황별 어떻게 행동해야할지 프로그램을 짜서 입력해주면 됩니다. 대표적인 회피 방법이 은행원 알고리즘입니다.대

- **데드락 회피와 안전상태의 개념**
    
    **안전 상태'라는 것은 시스템이 각 프로세스들에게 데드락을 피할 수 있는안전한 순서(saf sequence)로 자원을 배분 할 수 있는 상태를 의미한다.** 
    
    예를 들어 시스템에 12개의 자원과 프로세스 P0, P1, P2 이렇게 3개가 있다고 가정하자. 
    프로세스는 자기가 맡은 작업을 처리하기 위해 아래와 같은 개수의 자원을 필요로 한다.
    
    - P0은 작업을 마치기 위해 10개의 자원이 필요하다고 시스템에 요청했다.
    - P1은 작업을 마치기 위해 4개의 자원이 필요하다고 시스템에 요청했다.
    - P2는 작업을 마치기 위해 9개의 자원이 필요하다고 시스템에 요청했다.
    
    각 프로세스들이 작업을 마치기 위해 필요한 자원은 위와 같고 특정 시점 'T0'에서 시스템이 파악한 자원 할당 상태는 아래와 같다.
    
    - P0은 지금 5개의 자원을 가지고 있다. 작업을 마치기 위해 5개의 자원이 더 필요 하다.
    - P1은 지금 2개의 자원을 가지고 있다. 작업을 마치기 위해 2개의 자원이 더 필요 하다.
    - P2은 지금 2개의 자원을 가지고 있다. 작업을 마치기 위해 7개의 자원이 더 필요 하다.
    - 시스템에는 현재 12개의 자원 중 3개의 자원이 남아 있다.
    
    이 상태에서 시스템은 P1 -> P0 -> P2 순서로 자원을 할당하여 안전 상태를 유지 할 수 있다. 
    
    - 시스템에는 3개의 여유 자원이 있다. P1이 필요 자원 2개를 할당 받아 작업을 처리하고 자신이 가진 자원 4개를 반납한다.
    - 시스템에는 5개의 여유 자원이 있다. P0이 필요 자원 5개를 할당 받아 작업을 처리하고 자신이 가진 자원 10개를 반납한다.
    - 시스템에는 10개의 여유 자원이 있다. P2이 필요 자원 7개를 할당 받아 작업을 처리하고 자신이 가진 자원 9개를 반납한다.
    
    쉽게 말하자면! 시스템에 남아있는 자원과 현재 각 프로세스들이 필요로 하는 자원을 비교해서 우선순위를 매긴 다음, 그거에 맞게 자원을 배분하고 받아오는 개념입니다,,,
    
    이로써 데드락 상황이 발생하지 않고 모든 프로세스들이 작업을 완료 했다. 이렇게 데드락 회피는 프로세스가 자원을 요청 할 때 마다 '안전 상태'를 유지 할 수 있을 경우에만 자원을 할당하고, 그렇지 않을 경우 프로세스를 기다리게 함으로써 데드락을 피해간다.
    
    출처:
    
    [https://kukuta.tistory.com/281](https://kukuta.tistory.com/281)
    

**은행원 알고리즘(Banker's Algorithm)**

- 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
- 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태 회피
- **안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기**

** 은행원 알고리즘에 대해서 깊이 알아보지는 않고 개념정도만 훝었는데, 추후 스프린트에서 코드 형태로 살펴보면 완전 좋을 거 같네요!! 

### **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%80%E1%85%AD%E1%84%8E%E1%85%A1%E1%86%A8-%E1%84%89%E1%85%A1%E1%86%BC%E1%84%90%E1%85%A2%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%90%E1%85%A1%E1%86%B7%E1%84%8C%E1%85%B5-%E1%84%92%E1%85%AC%E1%84%87%E1%85%A9%E1%86%A8)교착 상태를 탐지 & 회복**

다음은 교착 상태가 되도록 허용한 다음 회복시키는 방법입니다. 

1. **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%90%E1%85%A1%E1%86%B7%E1%84%8C%E1%85%B5-detection)탐지(Detection)**
    
    자원 할당 그래프를 통해 교착 상태를 탐지함
    
    - 자원할당 그래프란? : 프로세스와 자원의 할당관계를 시각화한 그림
        
        <img width="831" alt="image" src="https://user-images.githubusercontent.com/103009135/190204804-91093b68-32f4-42c6-826d-3c167f0fdad1.png">

        
    
    자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함
    
2. **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%92%E1%85%AC%E1%84%87%E1%85%A9%E1%86%A8-recovery)회복(Recovery)**
    
    교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
    
    **프로세스 종료 방법**
    
    - 교착 상태의 프로세스를 모두 중지
    - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
    
    **자원 선점 방법**
    
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
    - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점
    

### **[#](https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html#%E1%84%8C%E1%85%AE%E1%84%8B%E1%85%AD-%E1%84%8C%E1%85%B5%E1%86%AF%E1%84%86%E1%85%AE%E1%86%AB)주요 질문**

1. 데드락(교착 상태)가 뭔가요? 발생 조건에 대해 말해보세요.
2. 회피 기법인 은행원 알고리즘이 뭔지 설명해보세요.
3. 기아상태를 설명하는 식사하는 철학자 문제에 대해 설명해보세요.
    
    > 교착 상태 해결책
    > 
    > 1. n명이 앉을 수 있는 테이블에서 철학자를 n-1명만 앉힘
    > 2. 한 철학자가 젓가락 두개를 모두 집을 수 있는 상황에서만 젓가락 집도록 허용
    > 3. 누군가는 왼쪽 젓가락을 먼저 집지 않고 오른쪽 젓가락을 먼저 집도록 허용

## Additional Reference

[https://sujinnaljin.medium.com/ios-차근차근-시작하는-gcd-14-4aefd4ba1eb7](https://sujinnaljin.medium.com/ios-%EC%B0%A8%EA%B7%BC%EC%B0%A8%EA%B7%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-gcd-14-4aefd4ba1eb7) (iOS에서 데드락 개념)

[https://sujinnaljin.medium.com/ios-차근차근-시작하는-gcd-11-1d830eeec781](https://sujinnaljin.medium.com/ios-%EC%B0%A8%EA%B7%BC%EC%B0%A8%EA%B7%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-gcd-11-1d830eeec781) (iOS Concurrency 기본)
