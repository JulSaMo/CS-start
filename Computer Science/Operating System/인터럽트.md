// 22.09.07



# ❤️ 인터럽트

<br/>

### 🤔 운영체제와 하드웨어 간의 상호 동작<br/>

- 운영체제는 `레지스터(상태, 명령, 데이터 레지스터)`를 읽고 쓰는 것을 통해 `하드웨어 장치의 동작을 제어`할 수 있음<br/>

| 레지스터               | 하는일                                               |
| ---------------------- | ---------------------------------------------------- |
| 상태(Status) 레지스터  | 하드웨어 장치의 `현재상태`를 읽을 수 있는 레지스터   |
| 명령(Command) 레지스터 | 하드웨어 장치가 `특정동작을 하도록 요청`할 때 사용   |
| 데이터(Data) 레지스터  | 하드웨어 장치가 `데이터를 보내거나 받거나`할 때 사용 |

<br/>

**운영체제와 하드웨어 장치 간에 폴링을 통한 상호작용**<br/>

1. **폴링(Polling)**을 한다<br/>

   ```뜻
   폴링(Polling)
   - 운영체제가 하드웨어 장치의 상태 레지스터를 읽음으로써 명령 수신 여부를 주기적으로 확인하는 것
   - 즉. 하드웨어장치의 상태를 수시로 체크해 명령을 받을 수 있는지 확인하는 것

2. 운영체제가 **데이터 레지스터에 데이터를 전달**함<br/>
3. 운영체제가 **명령 레지스터에 명령을 기록**함<br/>
4. 운영체제는 하드웨어 장치가 **특정 동작을 처리하였는지 폴링 반복문**을 돌면서 기다린다. (성공/실패 코드를 받게 됨)<br/>

<br/>

👉폴링을 하는 동안에는 <u>다른 프로세스에게 CPU를 양도하지 않고</u> 하드웨어 장치가 동작을 완료할떄까지, 계속 <u>루프를 돌면서 하드웨어 상태를 체크</u>함<br/>

👉하드웨어 장치의 속도는 매우 느리기 때문에 **CPU를 많이 낭비**하게 된다.<br/>

<br/>

<br/>

<hr/>

### 🤔 인터럽트란?<br/>

> CPU가 프로그램을 실행하고 있을때, I/O 하드웨어 등의 장치에 예외 상황이 발생하여 처리가 필요한 경우,<br/>
>
> 현재 실행중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선처리가 필요함을 CPU에게 알리는 것<br/>

- 지금 수행 중인 일보다 `더 중요한일`(Ex. 입출력, 우선 순위 연산 등)이 발생하면 `그 일을 먼저 처리`하고 나서 하던 일을 계속해야함<br/>

<br/>

#### 인터럽트 발생 시!<br/>

- 운영체제는 디바이스를 폴링하는 대신 I/O 요청한 프로세스를 **블록** 시키고 **CPU를 다른 프로세스에게 양도<br/>**
- 장치가 끝마치면 하드웨어 인터럽트를 발생시키고 CPU는 운영체제가 미리 정의해놓은 `인터럽트 서비스 루틴(ISR)` 또는 `인터럽트 핸들러(Interrput Handler)`를 실행<br/>
-  `인터럽트 핸들러(Interrput Handler)`는 입출력 요청, I/O 대기중인 프로세스 꺠우기 등을 해 프로세스가 작업을 계속 할 수 있도록 함<br/>

<br/>

#### 인터럽트 종류<br/>

- 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트가 있음<br/>

| 구분                         | 내용                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| **외부<br/> 인터럽트**       | 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생<br/><br/>- 타이머 인터럽트 : 타이머가 일정한 시간 간격으로 중앙처리장치에 인터럽트 요청<br/>- 입출력 인터럽트 : 속토가 느린 입출력장치가 입출력 준비가 완료되었음을 알리기 위해 인터럽트 요청 |
| **내부 인터럽트<br/>(Trap)** | 잘못된 명령이나 데이터를 사용할 때 발생<br/>0으로 나누기, 오버플로우, 명령어를 잘못 사용한 경우(Exception)<br/><br/><br/>-하드웨어 인터럽트 : 컴퓨터 고장, 데이터 전달 과정에서 비트 오류, 전원이 나간 경우<br/>-실행할 수 없는 명령어 : 기억장치에서 인출한 명령어의 비트 패턴이 정의되어 있지 않은 경우<br/>-명령어 실행 오류 : 나누기 0ㅇ을 하는 경우<br/>-사용 권한 위배 : 사용자가 운영체제만 사용할 수 있는 자원에 액세스하는 경우 |
| **소프트웨어 <br/>인터럽트** | 프로그램 처리 중 명령의 요청에 의해 발생한 것(SVC 인터럽트)<br/>-사용자가 프로그램을 실행시킬떄 발생 : 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할처리를 위해 자원 할당 동작이 수행 |

<br/>

<br/>

### 🤔 인터럽트 처리과정

![image-20220907201822231](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220907201822231.png)

- 명령어 사이클은 `인출(Fetch Stage)`과 `실행(Execution Stage)` 두 단계를 반복 수행<br/>

- 이때, 인터럽트 요청이 들어오면 ❗️바로 이를 처리하는 것이 아니라 `명령어 N의 실행 단계를 마쳐야함`<br/>
- 명령어의 실행 단계를 마칠때마다, 중앙처리장치(CPU)는 반복적으로 인터럽트 요청이 있는지 확인<br/>
  - 인터럽트 요청이 있으면 `인터럽트 서비스 단계를 진행`<br/>

<br/>

#### 좀 더 큰 개념으로 살펴본다면<br/>

![image-20220907202334448](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220907202334448.png)

**주 프로그램이 실행되다가 인터럽트 발생 시❗️<br/>**

- 현재 수행 중인 프로그램을 멈추고, **상태 레지스터와 PC 등을 스택에 잠시 저장**한 뒤에 **인터럽트 서비스**으로 간다.<br/>
  - 잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난뒤 다시 원래 작업으로 돌아와야 하기 때문<br/>

```요약
⁉️ Process A 실행 중 디스크에서 어떤 데이터를 읽어오라는 명령을 받음

1.  Process A는 System Call을 통해 인터럽트를 발생
2. CPU는 현재 진행중인 기계어 코드를 완료
3. 현재까지 수행중이였던 상태를 해당 Process의 PCB(Process Control Block)에 저장함
   (수행중이던 메모리주소, 레지스터 값, 하드웨어 상태 등..)
4. PC(Program Counter, 레지스터)에 다음에 실행할 명령의 주소를 저장
5. 인터럽트 벡터를 읽고 ISR 주소 값을 얻어 ISR(Interrupt Service Routine)러 점프하여 루틴을 실행
6. 해당 코드를 실행함
7. 해당 일을 다 처리하면, 대피시킨 레지스터를 복원
8. ISR의 끝에 IRET 명령어에 의해 인터럽트가 해제된다.
   - IRET : Intel 아키테처의 어셈블리 명령어 중 하나로 
   					'인터럽트 처리 시에 모튼 처리를 완료하고 다시 태스트로 복구하는 명령어'
9. IRET 명령어가 실행되면, 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원
	- 인터럽트 번호는 예외상황 인터럽트를 제외하고 운영체제가 결정!
```

<br/>

<br/>

### 🤔 폴링 VS 인터럽트<br/>

- 컨트롤러가 입력을 받아드리는 방법(우선순위 판별방법)에는 두가지가 있음<br/>

**폴링**<br/>

- 사용자가 명형어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식<br/>

- 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 실행(하드웨어에 비해 속도느림)<br/>

  ![image-20220907212058029](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220907212058029.png)

```폴링
프로세스 1이 실행 중에 Disk로부터 I/O 요청이 발생 시

- 운영체제는 I/O 요청이 완료될때까지 반복적으로 폴링한다.
- 디스트가 I/O 요정의 처리를 완료하면 프로세스 1이 다시 동작한다.

=> 플링을 하는 시간에는 원래하던 일에 집중할 수 없어 더 많은 기능을 제대로 수행하지 못함
```

<br/>

**인터럽트**<br/>

- MUC(Micro Controller Unit, 컴퓨터) 자체가 하드웨어적으로 변화를 체크하여 변화시에만 일정한 동작을 하는 방식<br/>
- 인터럽트 방식은 하드웨어로 지원받아야하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능!<br/>
  - 따라서 **실시간 대응이 필요할 때 필수적인 기능!**<br/>
- 즉, 인터럽트는 **발생 시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법!<br/>**

![image-20220907212123054](/Users/yuahyeon/Library/Application Support/typora-user-images/image-20220907212123054.png)

```요약
프로세스 1이 실행 중에 Disk로부터 I/O 요청이 발생 시

- 요청을 처리하는 동안에 운영체제는 프로세스 2를 CPU에서 실행
- 프로세스 1에 대한 디스크 요청이 완료되면, 인터럽트를 발생 시켜 운영체제는 프로세스 1을 다시 CPU에서 실행

=> 이처럼 인터럽트를 사용하면 CPU 연산과 I/O 장치 작업을 중첩시켜 수행할 수 있게 됨
=> 그렇기 때문에 폴링보다 CPU 사용률을 높일 수 있음
=>
```



<br/>하지만 인터럽트가 무조건 폴링보다 좋다고 할 수 없음

```예시
- 단 한번의 폴링으로만 끝날 정도의 빠른 하드웨어 장치라면 인터럽트보다 폴링이 더 효율적
- 인트럽트를 시용하면 현재 실행중인 프로세스를 다른 프로세스로 문액교환(COntext Switcing)하게되고 이때 많은 비용이 수반
=> 그렇기 때문에 빠른 하드웨어 장치라면 폴링이 더 효율적이고, 느린 하드웨어 장치라면 인터럽트가 더 효율적❗️
```

<br/>

<br/>

<hr/>

출처

https://dar0m.tistory.com/257?category=976685

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Operating%20System/Interrupt.md