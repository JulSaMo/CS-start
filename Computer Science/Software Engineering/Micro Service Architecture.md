//2022.09.20 Noel



# ❤️마이크로서비스 아키텍처(MSA)<br/>

<br/>

#### 들어가기에 앞써! 🤚<br/>

## 🤔모놀리식 아키텍처 (Monolithic Architecture)란?<br/>

- `모놀리식 아키텍처`는 `마이크로서비스(MSA) 아키텍처`에 반대되는 개념<br/>

- 애플리케이션의 모든 구성 요소가 한프로젝트에 통합되어 있는 형태<br/>

<img width="962" alt="image" src="https://user-images.githubusercontent.com/103012104/191277483-c3729032-fd44-49ba-b168-006500afdf6c.png">

<br/>

#### 장점<br/>

- 개발 초기에 단순한 아키텍처 구조로 인해 개발에 용이<br/>
- 어떤 서비스든지 개발되어 있는 환경이 같아서 복잡하지않음<br/>
- 배포가 간단함<br/>
- 확장성이 쉽다<br/>
  - 로드 밸런스를 이용하여 로드 부하를 나눠가지는 방식으로 진행<br/>
- 쉽게 고가용성 서버 환경을 만들 수 있다.<br/>
- End-to-End 테스트가 용이<br/>

<br/>

#### 단점<br/>

- 프로젝트의 규모가 커짐에 따라 애플리케이션 구동 시간이 늘어나고 빌드 및 배포 시간이 길어짐<br/>
- 조그마한 수정 사항이 있어도 전체를 다시 빌드하고 배포해야함<br/>
- 많은 양의 코드가 몰려 있어서 개발자가 모든 코드를 이해하기 힘들며, 유지 보수가 어려움<br/>
- 일부분의 오류가 전체에 영향을 미침 (장애가 전파됨)<br/>
- 기술 스택이 한 번 정해지면 바꾸기 어려움<br/>
- 전체 애플리케이션 확장은 쉽지만, 부하 분산을 위해 각 컴포넌트를 독립적으로 확장하기 어려움<br/>

<br/><br/><br/>

<hr/>

## 🤔마이크로서비스(MSA) 아키텍처란?<br/>

- MSA 아키텍처는 하나의 큰 애플리케이션을 여러 개의 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 형태<br/>
- 작은 레고 블록(Microservice) 하나 하나를 붙여 어떠한 큰 결과물을 만드는 레고 같은 것<br/>

<img width="954" alt="image" src="https://user-images.githubusercontent.com/103012104/191277586-bc9511b1-f29f-4d1a-a7a9-e4fcd84d8a6b.png">

<br/>

#### Micro Service?<br/>

```
"the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API.

마이크로서비스 아키텍처 스타일은 단일 애플리케이션을 작은 서비스들의 모음으로 개발하는 접근법이며, 각각 자체 프로세스에서 실행되며 종종 HTTP 리소스 API와 같은 경량 메커니즘과 통신한다.


These services are built around business capabilities and independently deployable by fully automated deployment machinery."

이러한 서비스는 비즈니스 기능을 기반으로 구축되며 완전히 자동화된 배포 시스템을 통해 독립적으로 배포할 수 있습니다."

-마틴파울러가 정의한 MSA
```



- 마이크로 서비스는 스스로 돌아갈 수 있으며, 독립적으로 배포가능한 서비스<br/>
- 마이크로 서비스 특징<br/>
  - 각각의 서비스는 그 크기가 작을 뿐, 서비스 자체는 하나의 모놀리식 아키텍처와 유사한 구조<br/>
  - 각각의 서비스는 독립적으로 배포가 가능해야함<br/>
  - 각각의 서비스는 다른 서비스에 대한 의존성이 작아야함<br/>
  - 각 서비스는 개별 프로세스로 구동되며, REST API와 같은 가변운 방식으로 통신되어야함<br/>
- 마이크로 서비스 단위<br/>
  - 마이크로 서비스의 단위는 하나의 기능, 하나의 프로젝트가 될 수 있으나,<br/>
  - 각 팀의 상황에 맞게 경계를 잘 정해서 설계하면 됨<br/>

<br/>

### 장점<br/>

| 관점                  | 내용                                                         |
| --------------------- | ------------------------------------------------------------ |
| ① 배포관점            | - 서비스 별 개별 배포가 가능 (배포 시 전체 서비스의 중단이 없음)<br/>- 독립 배포가 가능하므로 개발자의 자율성이 증가 <br/>예) 내가 A가능 만들고, 다른 사람이 B기능 못 만들었으면 나는 그냥 놀아도 됨<br/>-요구 사항을 신속하게 반영하여 빠르게 배포 할 수 있음 |
| ② 확장 관점           | - 특정 서비스에 대한 확장성이 용이<br/>- 클라우드 사용에 적합 |
| ③ 장애 관점           | - 장애가 전체 서비스로 확장될 가능성이 적음<br/>- 부분적 장애에 대한 격리가 수월 |
| ④ 코드/유지 보수 관점 | - 팀 별로 프로젝트가 분리되어 있으므로 코드의 이해도가 증가하고, 그에 따라 유지보수가 쉬움<br/>- 신기술의 적용이 유연하고, 서비스를 Polyglot하게 개발 및 운영 할 수 있음<br/>(Polyglot 개발 : 여러 프로그래밍 언어, 패러다임 등을 사용) |

<br/>

### 단점<br/>

| 관점                     | 내용                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ① 성능 관점              | - 서비스 간 호출 시 API를 사용하기 때문에 통신 비용 및 지연시간이 증가 |
| ② 데이터 관리 관점       | - 데이터가 여러 서비스에 걸쳐서 분산되므로 한번에 조회하기 어렵고, 데이터의 정합성 또한 관리하기 어려움 |
| ③ 테스트 / 트랜잭션 관점 | - 단위 테스트는 쉽지만, 통합 테스트 및 End - to End 테스트 단위로 들어가면 여러 서비스의 API를 검증해야하므로 시간과 비용이 많이 든다.<br/>- 각 서비스 별로 데이터베이스가 있으므로 트랜잭션을 구현하기 까다롭다.<br/>- 아키텍처가 다소 복잡하므로 개발 및 관리가 어렵고 비용이 많이 듦 |

<br/>

<br/>

<br/>

## MSA 아키텍처의 구조<br/>

MSA는 크게 내부 아키텍처와 외부 아키텍처로 구분

- 아래 이미지 : 남색 = 내부 아키텍처 / 회색 = 외부 아키텍처

<img width="983" alt="image" src="https://user-images.githubusercontent.com/103012104/191277735-c34217e4-1899-459b-a7e8-312132fe218d.png">


<br/>

### 내부 아키텍처

- 내부 아키텍처는 `내부 서비스`와 관련된 아키텍처로,  
  - 내부 서비스를 어떻게 잘 쪼개는지에 대한 설계라고 생각하면됨
- 내부 아키텍처는 각 비즈니스, 서비스, 시스템마다 각각의 특성이 있기 때문에 정해진 것은 없음
  - 각자 알아서 팀 사정에 맞춰서 구현하면 됨
  - 표준이 없기 때문에 MSA를 설계하는데 가장 어려운 부분

| 구분     | 내용                                                         |
| -------- | ------------------------------------------------------------ |
| 고려사항 | ① 마이크로 서비스를 어떻게 정의 할 것인가<br/>② DB 접근 구조를 어떻게 설계할 것인가<br/>- 일부 비즈니스 트랜잭션은 여러 마으크로 서비스에 걸쳐있기 떄문에, 각 서비스에 연결된 데이터베이스의 정합성을 보장해야함<br/>③ 마이크로 서비스 내 API를 어떻게 설계할 것인가 등 |



<br/>

### 외부 아키텍처

- 맨 위의 그림에서와 같이 Gartner에서는 MSA의 Outer architecture을 총 6개의 영역으로 분류

  ```
  1. External Gateway
  2. Service Mesh
  3. Container Management
  4. Backing Services
  5. Telemetry
  6. CI/CD Automation
  ```



#### ① External Gateway<br/>

- 외부 게이트웨이는 전체 서비스 외부로부터 들어오는 접근을, 내부 구조를 드러내지 않고 처리하기 위한 요소<br/>

- 사용자 인증과 권한 정책 관리 등을 수행하며, API 게이트웨이가 가장 핵심적인 역할.<br/>

- API 게이트웨이는 서버 최앞단에 위치하며 모든 API 호출을 받음, 받은 API 호출을 인증 한 후 적절한 서비스에 메시지 전달 (routing)<br/>

  <img width="968" alt="image" src="https://user-images.githubusercontent.com/103012104/191277861-59768d0d-62f4-49a6-b9b1-4e926398e9af.png">


<br/>

### ② Service Mesh

- Service Mesh는 마이크로서비스 구성 요소간의 네트워크를 제어하는 역할
- 서비스 간에 통신을 하기 위해서는 `service discovery`, `service routing`, `트래픽 관리 및 보안` 등을 담당하는 요소가 있어야 하는데 이 기능을 `Service Mesh`가 수행

<img width="950" alt="image" src="https://user-images.githubusercontent.com/103012104/191277908-4b991260-0d42-4c9e-9683-94c45e29e21a.png">

<br/>

### ③ Container Management

- 컨테이너 기반 어플리케이션 운영은 유연성과 자율성을 가지며, 
- 개발자가 손쉽게 접근 및 운영할 수 있는 인프라 관리 기술이기 때문에 MSA에 적합하다고 평가

- 대표적인 컨테이너 관리 환경인 `Kubernetes`가 `Container management`에 많이 사용

<img width="960" alt="image" src="https://user-images.githubusercontent.com/103012104/191278000-4f0cd585-992d-47fd-a492-96d451d34502.png">

<br/>

### ④ Backing Service

- `Backing Service`는 어플리케이션이 실행되는 중 네트워크를 통해서 사용할 수 있는 모든 서비스

- My SQL과 같은 `데이터베이스`, `캐쉬 시스템`, `SMTP 서비스` 등 어플리케이션과 통신하는 `attached Resource`들을 지칭하는 포괄적인 개념

- MSA에서의 특징적인 Backing service

  -  `Message queue` : MSA에서는 메세지의 송신자와 수신자가 직접 통신하지 않고 `Message Queue`를 활용하여 `비동기적으로 통신`하는 것을 지향합니다.

    ```예시
    이해를 위한 예시
    MSA를 적용한 프로젝트에서 장애 발생이 일어났다고 가정 시
    이 경우, 마이크로서비스 오케스트레이션이 진행되면서, 새로운 마이크로 서비스를 신규 생성하거나 재생성 등의 작업을 진행
    
    만약 Message Queue를 사용하지 않는 강한 결합 구조의 경우, 
    여러 서비스를 걸치는 실시간 트랜잭션을 처리할 때, 하나의 서비스가 죽어버린다면 트랜잭션이 끊어지기 때문에 해당 서비스 요청을 보존할 수 없고 큰 에러가 발생함 또한 REST 통신으로 트랜잭션 실패에 대한 처리를 구현하는 방법은 굉장히 복잡
    
    MSA에서 데이터 변경이나, 보상 트랜잭션과 관련된 처리는 Message Queue를 활용한 비동기 처리가 효율적
    ```

<br/>

### ⑤ Telemetry<br/>

- `Telemetry`의 어원은 Tele(먼 거리) + metry(측정)<br/>
- MSA에서는 상당수의 마이크로서비스가 `분산환경에서 운영`되기 때문에 <br/>
  - 서비스들의 상태를 일일이 모니터링하고, <br/>
  - 이슈에 대응 하는 것은 굉장히 힘들고 오랜 시간이 걸립니다.<br/>

- ` Telemetry`는 서비스들을 모니터링하고, 서비스별로 발생하는 이슈들에 대응할 수 있도록 환경을 구성하는 역할<br/>

<br/>

### ⑥ CI/CD Automation

- `CI/CD`는 어플리케이션 개발 단계를 자동화하여, 어플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법

- `지속적인 통합(Continuous Integration)`, `지속적인 전달(Continuous Delivery)`, `지속적인 배포(Continuous Deployment)`가 CI/CD의 기본 개념
- 이를 자동화하는 것은 배포가 잦은 MSA 시스템에 꼭 필요한 요소

<br/><br/><br/>

## 모놀리식 아키텍처 VS 마이크로 서비스 아키텍처 <br/>

<img width="975" alt="image" src="https://user-images.githubusercontent.com/103012104/191278134-83cf1a3d-196e-403f-9ef1-457915e0512d.png">
<img width="970" alt="image" src="https://user-images.githubusercontent.com/103012104/191278171-f58ae6a8-7aaf-4a0a-8dd0-0addb3c7dfa1.png">



### 각각 아키텍처는 언제 사용될까?<br/>

초기 시작은 프로젝트 규모가 작은 경우가 많아 `모놀리식 아키텍처`를  사용하다가 <br/>

아래 관점들을 비교했을 때 이득이 된다면 MSA 아키텍처로 전환!<br/>

| 구분            | 내용                                                         |
| --------------- | ------------------------------------------------------------ |
| **비용**        | MSA 아키텍처를 도입할 경우, 모놀리식 아키텍처에 비해 비용을 얼마나 절감할 수 있는가? |
| **개발 생산성** | 마이크로 서비스를 요구할 만큼 시스템 복잡도가 높은가? 또는 복잡도를 지나치게 높인 마이크로 서비스가 생산성을 저해하고 있진 않은가? |
| **운영**        | 개발 팀에게 개발과 운영을 동시에 할 만큼 인프라가 준비되어 있는가? 또는 개발 인력이 마이크로 서비스를 관리할 역량이 있는가? |
| **배포**        | 배포를 충분히 자주 하고 있는가? MSA는 빠른 변화에 대응하기 위해 도입하는 것인데, 회사마다 배포 일이 정해져 있고, 배포가 가끔 일어난다면 효율이 떨어진다. |







<hr/>

참고하면 좋은 블로그

http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/

출처

https://steady-coding.tistory.com/595

https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-MSA-Outer-Architecure
