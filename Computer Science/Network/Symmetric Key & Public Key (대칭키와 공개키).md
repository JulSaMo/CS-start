# 🟠 대칭키 (Symmetric Key)
```
암호화에서 사용되는 키와, 복호화에서 사용되는 키가 동일한 암호키 (대칭키 암호화 알고리즘 이라고도 불린다.)
하나의 키를 양쪽(client & server) 가 같이 사용한다. 
```
<p align="center"><img width="594" alt="image" src="https://user-images.githubusercontent.com/96969693/187076937-9a8f7974-5250-494c-a3ab-6a2a6e8eba2f.png"></p>

## 🔸 대칭키 장점
- 공개키 암호화 방식에 비해서 암호화 및 복호화 속도가 빠르다. (한 키를 가지고 암호화/복호화 둘다 하니까?)
- 연산속도가 빠르고 구현이 용이하다.
- 손쉽게 기밀성을 제공한다.
- 암호화할 수 있는 평문의 길이에 제한이 없다. (대량 data 암호화에 주로 이용된다.)

## 🔸 대칭키 단점
- 키 관리가 어렵다.
- 인증, 무결성 지원이 부분적으로만 가능하며, 부인방지기능을 제공하지 못한다.

```
부인방지: 메시지의 송수신이나 교환 후, 또는 통신이나 처리가 된 후에 
그 사실을 사후에 증명함으로써 사실 부인을 방지하는 보안 기술이다. 
```
[부인방지관련 더보기](https://spongeb0b.tistory.com/292)

- 암호화 통신을 하는 사용자들끼리 같은 대칭키를 공유해야만 한다.
  - 물리적으로 만나서 전달하지 않는 한, 대칭키를 전달하는 과정에서 해킹의 위험에 노출 될 수 있기 때문에 단점이다.
- 관리해야할 키의 개수가 방대해진다.

## 🔸 대표적인 대칭키 알고리즘
- SEED: 공인인증서의 암호화 방식으로 유명
- DES
- 3DES
- AES
- ARIA
- ChaCha20: 최근 주목받고 있는 



# 🟠 공개키 (Public Key) = 비대칭키 라고도 불림
```
암호화 복호화에 사용하는 암호키를 분리한 알고리즘. 
공개키와 비밀키 두개가 존재한다.
```

<p align="center"><img width="581" alt="image" src="https://user-images.githubusercontent.com/96969693/187319243-9954a6dd-d445-4166-92c7-fb6d5640e8ed.png"></p>

공개키만 대중에게 공개하고, 암호화된 데이터는 고유한 비밀키 (Private Key)로만 복호화할 수 있다. 이 비밀키를 가진 사용자만 내용을 열어볼 수 있다. (복호화할 수 있는 키만 비밀로 간직하는 것이다.)
이런 특징때문에 전자서명, 공인인증서 등에 다양하게 이용된다.


## 🔸 공개키 장점
- 수신자의 개인키로만 해독할 수 있으므로 안전하다.
- 대칭키에 비해서 속도가 약 1000배 느리다.
- 키의 분배 및 관리가 용이하다.
- 사용자의 증가에 따라 관리할 키의 개수가 상대적으로 적다.
- 키 변화의 빈도가 적다. (복호화(private key)는 길고 복잡하다.)
- 기밀성, 인증, 무결성을 지원하고, 특히 부인방지 기능을 제공한다.

## 🔸 공개키 단점
-  키의 길이가 길고 연산속도가 느리다.
-  암호화할 수 있는 평문의 길이에 제한이 있다.

## 🔸 대표적인 공개키 알고리즘
- Diffie Hellman: 최초의 공개키 알고리즘, 위조에 취약하다.
- RSA: 대표적 공개키 알고리즘
- DSA: 전자서명 알고리즘 표준
- ECC: 짧은 키로 높은 암호 강도, 빠른 구현 가능, (PDA, 스마트폰에서 사용)

## 🔸 공개키 특징
### 👉 공개키(비대칭키) 방식이 대칭키 방식보다 키 관리가 쉬운 이유
1. 대칭키 방식의 키 관리 
  - 키 분배센터를 이용하겠지만, 수신자는 각각의 비밀키를 관리해야 한다. 그러므로, 키 관리의 불편함이 존재하게 된다.

2. 공개키 방식의 키 관리
  - 예시상황
    - 송신자가 자신의 메시지를 수신자 A의 공개키로 암호화하여 A에게 전달했다 치자. 
      A는 자신의 개인키 하나로 받은 메시지들을 복호화 할 수 있다. 따라서 공개키 방식에서 수신자 A는 자신의 개인키만 관리하면 된다.
      즉, 사용자가 많아져도, 수신자 A는 자신의 개인키만 관리하면 되므로 키 관리가 대칭키 방식보다 훨씬 수월하다.
      
### 👉 공개키 방식에서 부인방지기능 제공 방법
1. 부인방지 서비스 제공 방법: 송신자나 수신자가 메시지를 주고받은 사실을 부인하지 못하도록 방지하는 것
  - 기밀성: 공개키로 암호화해서 제공
  - 무결성: 해시값을 비교해서 확인
  - 가용성: 백업 및 이중화
  - 부인방지: 송신자의 개인키로 암호화 후 수신측에서 송신자의 공개키로 복화해서 확인
2. 송신자 인증 및 부인방지
  - A의 공개키로 복호화 됐다는 의미는 A의 개인키로 암호화했다는 것이다. 즉 A만 갖고 있는 A의 개인키르 암호화 했다는 것이므로 송신자 인증 및 부인방지 기능을 제공하는 것이다.
    (공개키 암호에서 전자서명에 사용하는 서명자 개인키는 오로지 서명자만이 사용할 수 있기 때문)

# 🟠 시나리오로 이해하기

## 🔸 대칭키 암호화 시나리오
```
1. A는 사전에 공유된 대칭키로 데이터를 암호화 하여 B에게 전송한다.
2. B는 같은 대칭키로 데이터를 복호화한다.
```

## 🔸 공개키 암호화 시나리오
```
1. A가 웹상에 공개된 B의 공개키를 이용하여 평문을 암호화 한다.
2. 이 암호문은 B가 개인적으로 갖고 있는 B의 비밀키로만 복호화가 가능하다. B는 자신의 비밀키로 복호화한 평문을 확인하고, A의 공개키로 응답을 암호화하여 A에게 보낸다.
3. A는 A의 비밀키로 암호화된 응답문을 복호화한다.
```
- 장점: 대칭키의 단점을 완벽하게 해결했다. (같은 대칭키를 공유해야한다는 단점을 극복했다.)
- 단점: 암호화/복호화가 매우 복잡하다. (키가 서로 다르기 때문에)

## 🔶 하이브리드 방식 (대칭키+공개키)

대칭키 암호화와 공개키 암호화를 혼합한 응용 암호화 방식이다.
- 대량의 메시지 암호화에는 대칭키 방식을 이용하며, 키 관리는 공개키 방식을 혼합하여 사용

```
1. A의 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하여 B에게 보낸다.
2. B는 암호문을 받아 자신(B)의 비밀키로 복호화 한다.
3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화 하여 A에게 보낸다.
4. A는 자신의 대칭키로 암호문을 복호화한다.
5. 계속 대칭키로 암호화 통신을 한다.
```


-> 이 방식은 SSL(Secure Socket Layer)의 시초가 되었다. (https에서 더 자세한 개념을 다룰 예정)


# 🟠 디지털 인증서 원리

<p align="center"><img width="609" alt="image" src="https://user-images.githubusercontent.com/96969693/187327946-67172d8a-646e-4857-86de-71ed846ac2a8.png"></p>

디지털 인증서에는 모두가 신뢰할 수 있는 제삼자인 CA와 공개키(비대칭키)암호화가 필요하다.
1. B는 CA(그림에서 Client Server)에게 자신이 B임을 증명하고 자신의 공개키가 B의 공개키가 맞음을 인증하는 인증서를 발급한다. 
2. A에게 B의 공개키가 포함된 이 인증서를 주면, 이를 받은 A는 자신이 신뢰할 수 있는 CA에게 CA가 진짜 발급한 인증서인지 확인하고
3. 맞으면 그 인증서에 포함된 B의 공개키로 데이터를 암호화해서 B를 전달한다. 

만약 최종적으로 B가 올바르게 자신의 개인키로 복호화한다면, CA가 인증하는 B의 공개키에 대응하는 개인키를 갖고 있다는 뜻이므로,
이 과정을 통해 현재 통신하고 있는 상대방이 B가 맞음을 인증할 수 있다.


# 🟠 기밀성 보장을 위한 노력
## 🔸 키 합의 프로토콜
대칭키 암호화를 사용하기 위해 안전하지 않은 네트워크 상에서 안전하게 키를 교환할 수 있어야한다.
이런 역할을 하는 알고리즘을 key exchange, key agreement, key establishment등 여러 이름으로 불리는데, 여기선 ```키 합의 프로토콜```이라고 하겠다.

### 🔸 RSA 키 합의 프로토콜
RSA는 대표적인 공개키 알고리즘이다.
<p align="center"><img width="965" alt="image" src="https://user-images.githubusercontent.com/96969693/187340725-7d1d0a6a-af7c-4de8-bae5-7bc8dac4ebc3.png"></p>

공개키 암호화인 RSA를 사용한 키 합의 프로토콜. (그림에서) 앨리스는 앞으로 통신에 사용할 세션키를 만들어서 이를 Bob의 공개키로 암호화한 다음, Bob에게 전송한다. Bob은 자신의 공개키로 암호화된 세션키를 복호화해서 사용한다. 

```
💡 세션키: 하나의 통신 세션에서 모든 메시지를 암호화하기 위해서 사용되는 1회용 대칭키
```

#### 👉 문제점
앨리스가 Bob 과 앨리스의 통신기록을 모두 기록했다고 치자. 추후 Bob의 개인키를 알아내어 복화해서 모든 통신기록을 복호화해서 세션키와 세션키를 통한 대화내용을 모두 얻을 수 있게된다는 단점이 있다.

#### 👉 해결방법
현재에만 안전한 것이 아니라, 미래에 개인키가 유출되어도 안전하게 하는 보안 목표를 ```'순방향 비밀성'``` 혹은 ```'완전 순방향 비밀성 (perfect forward secrecy, PFS)'```이라고 한다.
RSA에는 순방향 비밀성이 제공되지 않는다. (????? 그럼 RSA말고 다른 알고리즘을 사용하는게 해결방법이라는건가??)

### 🔸 Diffie Hellman
키 교환 알고리즘으로, 대칭키를 공유하는데 사용된다.
(아마 해결방법으로 디피-헬만 알고리즘을 추천하는것 같다.)
최초의 공개키 알고리즘으로, 보안에 취약하다는 단점이 있다.

<p align="center"><img width="298" alt="image" src="https://user-images.githubusercontent.com/96969693/187362461-749bc860-056a-4583-ace3-2ebefa56e6b9.png"></p>

- 안전하지 않은 채널에서 안전하게 세션키를 전달할 수 있는 알고리즘
- 순방향 비밀성 보장
  - 세션키를 만들 수 있는 힌트만을 네트워크 상으로 전달하기 때문
- 디프헬만의 핵심은, 상대방의 공개키와 나의 개인키를 이용해서 계산을 통해 비밀키를 만든다는 것이다.

```
< 시나리오 >
1. 앨리스와 밥은 통신에 사용할 기저키를 공개키로 정했다. (노란색)
2. 각자 비밀키를 정했다. (빨간색과 청록색)
3. 각자의 비밀키 + 기저키로 공개적으로 전송한다. (오랜지색, 파란색)
4. 받은 (상대방의 비밀키 + 기저키) + 자신의 비밀키 를 통해서 최종 공통키를 만든다. (갈색)
5. 각자의 비밀키를 즉시 삭제한다. (빨간섹, 청록색 삭제)

```

이렇게 하게 되면, 훗날 밥의 개인 키를 탈취하더라고 얻을 수 있는 것은 힌트 뿐이기 때문에 여전히 복호화하지 못한다. 
세션키를 만드는데에 사용된 비밀키들은 폐기 되었기 때문에 세션키를 탈취할 수 없다. 


#### 👉 디프헬만이 왜 취약한가?

<p align="center"><img width="662" alt="image" src="https://user-images.githubusercontent.com/96969693/187365823-34f70f2c-96f2-4243-bf19-798b91aaa87d.png"></p>

하지만 이 그림에서 T가 값을 조작해버린다면? Man In the Middle Attack에 당하게 된다.

디프헬만 알고리즘은 위와 같은 수식(?)으로 키를 교환한다. 여기서 보안이 왜 취약한지 설명해보자면,
1. A와 B 가 서로 g 를 통해 g^a mod p 와 g^b mod p 를 보낸다.
2. 중간에 T가 t라는 개인키로 서로에게 보내고 T는 g^at mod p 와 g^bt mod p 를 만든다.
3. A와 B는 눈치채지 못하고 t가 준 g^t mod p 를 이용해서 (원래는 전달받은 g^a , g^b를 이용해야함) 만들어버리면,
4. 이제 ABT 모두 같은 대칭키를 갖게 된다.
✨ 이렇게 되게 되면, 결국엔 T에게 공격을 당할 수 있는 상태가 완성된다.


# 🟠 무결성 보장을 위한 노력
## 🔸 해시함수

<p align="center"><img width="348" alt="image" src="https://user-images.githubusercontent.com/96969693/187367194-1ab87d4c-6bb0-4fd9-a6f4-22deaa022248.png"></p>


해시 함수는 어떤 임의의 데이터를 입력으로 받아서 일정한 길이의 데이터로 바꾸어주는 함수를 말하는데 이때 나오는 결과인 일정한 길이의 데이터를 해시 또는 해시값 이라고 한다.

해시함수는 암호학적으로 강점을 요소들을 가진다.

1. 해시 값만 보고서 데이터를 찾기 어려울 것
2. 특정 입력 데이터의 해시 값과 같은 해시 값을 가지는 다른 데이터를 찾기 어려울것
3. 같은 해시값을 가지는 서로 다른 두 입력 데이터를 찾기 어려울 것

이 세가지 요소들을 해시함수는 갖고있다!

### 👉 장점
전송 중에 메시지가 변경되었을 경우, 해시 값이 다르다면, 오염된 메시지임을 확인할 수 있다.

### 👉 문제점
수정 또는 변경은 감지할 수 있지만 위조는 발견하지 못한다.

이러한 문제점은, 키있는 해시함수를 통해서 극복할 수 있다.

## 🔸 키 있는 해시함수
키 있는 해시함수 중 가장 대표적인 ```메시지 인증 코드 (Message Authentication Code, MAC)```를 살펴보자.
메시지인증코드란, 대칭키 암호화 개념과 해시함수의 개념이 섞여있는 형태이다.

<p align="center"><img width="733" alt="image" src="https://user-images.githubusercontent.com/96969693/187367924-820b58c5-6b74-4243-b658-71260245262a.png"></p>

```
< 메시지 인증 코드를 이용한 인증 순서를 살펴보자 >
1. 송신자 앨리스와 수신자 밥은 사전에 키를 공유해 둔다. 
2. 송신자 앨리스는 송금 의뢰 메시지를 기초로 해서 MAC값을 계산한다. (공유키를 사용)
3. 송신자 앨리스는 수신자 밥에게 송금 의뢰 메시지와 MAC값을 보낸다.
4. 수신자 밥은 수신한 송금의뢰 메시지를 기초로해서 MAC값을 계산한다. (공유키를 사용)
5. 수신자 밥은 앨리스로부터 수신한 MAC값과 계산으로 얻어진 MAC값을 비교한다.
6. 수신자 밥은 2개의 MAC값이 동일하면 송금 의뢰가 틀림없이 앨리스로부터 온 것이라고 판단한다. (인증성공)
   동일하지 않다면 앨리스로 온게 아니라고 판단한다. (인증실패)
```



## 📝 References
[본문 사진 및 기본 대칭키 공개키 내용](https://hammii.tistory.com/m/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%8C%80%EC%B9%AD%ED%82%A4%EC%99%80-%EA%B3%B5%EA%B0%9C%ED%82%A4)
[암호화 복호호화 개념 및 장/단점](https://velog.io/@yanghl98/Network-%EB%8C%80%EC%B9%AD%ED%82%A4%EA%B3%B5%EA%B0%9C%ED%82%A4-Symmetric-KeyPublic-Key)
[암호화 복호화 장/단점 및 특징](https://retro-blue.tistory.com/40)
[디프헬만 알고리즘](https://www.crocus.co.kr/1233)
[키 합의 프로토콜, 무결성 및 기밀성을 위한 노력](https://velog.io/@gs0351/%EB%8C%80%EC%B9%AD%ED%82%A4-vs-%EA%B3%B5%EA%B0%9C%ED%82%A4%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4)


