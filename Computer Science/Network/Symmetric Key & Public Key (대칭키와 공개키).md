# 🟠 대칭키 (Symmetric Key)
```
암호화에서 사용되는 키와, 복호화에서 사용되는 키가 동일한 암호키 (대칭키 암호화 알고리즘 이라고도 불린다.)
하나의 키를 양쪽(client & server) 가 같이 사용한다. 
```
<p align="center"><img width="594" alt="image" src="https://user-images.githubusercontent.com/96969693/187076937-9a8f7974-5250-494c-a3ab-6a2a6e8eba2f.png"></p>

## 🔸 대칭키 장점
- 공개키 암호화 방식에 비해서 암호화 및 복호화 속도가 빠르다. (한 키를 가지고 암호화/복호화 둘다 하니까?)
- 연산속도가 빠르고 구현이 용이하다.
- 손쉽게 기밀성을 제공한다.
- 암호화할 수 있는 평문의 길이에 제한이 없다. (대량 data 암호화에 주로 이용된다.)

## 🔸 대칭키 단점
- 키 관리가 어렵다.
- 인증, 무결성 지원이 부분적으로만 가능하며, 부인방지기능을 제공하지 못한다.

```
부인방지: 메시지의 송수신이나 교환 후, 또는 통신이나 처리가 된 후에 
그 사실을 사후에 증명함으로써 사실 부인을 방지하는 보안 기술이다. 
```
[부인방지관련 더보기](https://spongeb0b.tistory.com/292)

- 암호화 통신을 하는 사용자들끼리 같은 대칭키를 공유해야만 한다.
  - 물리적으로 만나서 전달하지 않는 한, 대칭키를 전달하는 과정에서 해킹의 위험에 노출 될 수 있기 때문에 단점이다.
- 관리해야할 키의 개수가 방대해진다.

## 🔸 대표적인 대칭키 알고리즘
- SEED: 공인인증서의 암호화 방식으로 유명
- DES
- 3DES
- AES
- ARIA
- ChaCha20: 최근 주목받고 있는 



# 🟠 공개키 (Public Key) = 비대칭키 라고도 불림
```
암호화 복호화에 사용하는 암호키를 분리한 알고리즘. 
공개키와 비밀키 두개가 존재한다.
```

<p align="center"><img width="581" alt="image" src="https://user-images.githubusercontent.com/96969693/187319243-9954a6dd-d445-4166-92c7-fb6d5640e8ed.png"></p>

공개키만 대중에게 공개하고, 암호화된 데이터는 고유한 비밀키 (Private Key)로만 복호화할 수 있다. 이 비밀키를 가진 사용자만 내용을 열어볼 수 있다. (복호화할 수 있는 키만 비밀로 간직하는 것이다.)
이런 특징때문에 전자서명, 공인인증서 등에 다양하게 이용된다.


## 🔸 공개키 장점
- 수신자의 개인키로만 해독할 수 있으므로 안전하다.
- 대칭키에 비해서 속도가 약 1000배 느리다.
- 키의 분배 및 관리가 용이하다.
- 사용자의 증가에 따라 관리할 키의 개수가 상대적으로 적다.
- 키 변화의 빈도가 적다. (복호화(private key)는 길고 복잡하다.)
- 기밀성, 인증, 무결성을 지원하고, 특히 부인방지 기능을 제공한다.

## 🔸 공개키 단점
-  키의 길이가 길고 연산속도가 느리다.
-  암호화할 수 있는 평문의 길이에 제한이 있다.

## 🔸 대표적인 공개키 알고리즘
- Diffie Hellman: 최초의 공개키 알고리즘, 위조에 취약하다.
- RSA: 대표적 공개키 알고리즘
- DSA: 전자서명 알고리즘 표준
- ECC: 짧은 키로 높은 암호 강도, 빠른 구현 가능, (PDA, 스마트폰에서 사용)

## 🔸 공개키 특징
### 👉 공개키(비대칭키) 방식이 대칭키 방식보다 키 관리가 쉬운 이유
1. 대칭키 방식의 키 관리 
  - 키 분배센터를 이용하겠지만, 수신자는 각각의 비밀키를 관리해야 한다. 그러므로, 키 관리의 불편함이 존재하게 된다.

2. 공개키 방식의 키 관리
  - 예시상황
    - 송신자가 자신의 메시지를 수신자 A의 공개키로 암호화하여 A에게 전달했다 치자. 
      A는 자신의 개인키 하나로 받은 메시지들을 복호화 할 수 있다. 따라서 공개키 방식에서 수신자 A는 자신의 개인키만 관리하면 된다.
      즉, 사용자가 많아져도, 수신자 A는 자신의 개인키만 관리하면 되므로 키 관리가 대칭키 방식보다 훨씬 수월하다.
      
### 👉 공개키 방식에서 부인방지기능 제공 방법
1. 부인방지 서비스 제공 방법: 송신자나 수신자가 메시지를 주고받은 사실을 부인하지 못하도록 방지하는 것
  - 기밀성: 공개키로 암호화해서 제공
  - 무결성: 해시값을 비교해서 확인
  - 가용성: 백업 및 이중화
  - 부인방지: 송신자의 개인키로 암호화 후 수신측에서 송신자의 공개키로 복화해서 확인
2. 송신자 인증 및 부인방지
  - A의 공개키로 복호화 됐다는 의미는 A의 개인키로 암호화했다는 것이다. 즉 A만 갖고 있는 A의 개인키르 암호화 했다는 것이므로 송신자 인증 및 부인방지 기능을 제공하는 것이다.
    (공개키 암호에서 전자서명에 사용하는 서명자 개인키는 오로지 서명자만이 사용할 수 있기 때문)

# 🟠 시나리오로 이해하기

## 🔸 대칭키 암호화 시나리오
```
1. A는 사전에 공유된 대칭키로 데이터를 암호화 하여 B에게 전송한다.
2. B는 같은 대칭키로 데이터를 복호화한다.
```

## 🔸 공개키 암호화 시나리오
```
1. A가 웹상에 공개된 B의 공개키를 이용하여 평문을 암호화 한다.
2. 이 암호문은 B가 개인적으로 갖고 있는 B의 비밀키로만 복호화가 가능하다. B는 자신의 비밀키로 복호화한 평문을 확인하고, A의 공개키로 응답을 암호화하여 A에게 보낸다.
3. A는 A의 비밀키로 암호화된 응답문을 복호화한다.
```
- 장점: 대칭키의 단점을 완벽하게 해결했다. (같은 대칭키를 공유해야한다는 단점을 극복했다.)
- 단점: 암호화/복호화가 매우 복잡하다. (키가 서로 다르기 때문에)

## 🔶 하이브리드 방식 (대칭키+공개키)

대칭키 암호화와 공개키 암호화를 혼합한 응용 암호화 방식이다.
- 대량의 메시지 암호화에는 대칭키 방식을 이용하며, 키 관리는 공개키 방식을 혼합하여 사용

```
1. A의 B의 공개키로 암호화 통신에 사용할 대칭키를 암호화하여 B에게 보낸다.
2. B는 암호문을 받아 자신(B)의 비밀키로 복호화 한다.
3. B는 A로부터 얻은 대칭키로 A에게 보낼 평문을 암호화 하여 A에게 보낸다.
4. A는 자신의 대칭키로 암호문을 복호화한다.
5. 계속 대칭키로 암호화 통신을 한다.
```


-> 이 방식은 SSL(Secure Socket Layer)의 시초가 되었다. (https에서 더 자세한 개념을 다룰 예정)


# 🟠 디지털 인증서 원리

<p align="center"><img width="609" alt="image" src="https://user-images.githubusercontent.com/96969693/187327946-67172d8a-646e-4857-86de-71ed846ac2a8.png"></p>

디지털 인증서에는 모두가 신뢰할 수 있는 제삼자인 CA와 공개키(비대칭키)암호화가 필요하다.
1. B는 CA(그림에서 Client Server)에게 자신이 B임을 증명하고 자신의 공개키가 B의 공개키가 맞음을 인증하는 인증서를 발급한다. 
2. A에게 B의 공개키가 포함된 이 인증서를 주면, 이를 받은 A는 자신이 신뢰할 수 있는 CA에게 CA가 진짜 발급한 인증서인지 확인하고
3. 맞으면 그 인증서에 포함된 B의 공개키로 데이터를 암호화해서 B를 전달한다. 

만약 최종적으로 B가 올바르게 자신의 개인키로 복호화한다면, CA가 인증하는 B의 공개키에 대응하는 개인키를 갖고 있다는 뜻이므로,
이 과정을 통해 현재 통신하고 있는 상대방이 B가 맞음을 인증할 수 있다.


# 🟠 기밀성 보장을 위한 노력
## 🔸 키 합의 프로토콜
대칭키 암호화를 사용하기 위해 안전하지 않은 네트워크 상에서 안전하게 키를 교환할 수 있어야한다.
이런 역할을 하는 알고리즘을 key exchange, key agreement, key establishment등 여러 이름으로 불리는데, 여기선 ```키 합의 프로토콜```이라고 하겠다.

### 🔸 RSA 키 합의 프로토콜
RSA는 대표적인 공개키 알고리즘이다.
<p align="center"><img width="965" alt="image" src="https://user-images.githubusercontent.com/96969693/187340725-7d1d0a6a-af7c-4de8-bae5-7bc8dac4ebc3.png"></p>

공개키 암호화인 RSA를 사용한 키 합의 프로토콜. (그림에서) 앨리스는 앞으로 통신에 사용할 세션키를 만들어서 이를 Bob의 공개키로 암호화한 다음, Bob에게 전송한다. Bob은 자신의 공개키로 암호화된 세션키를 복호화해서 사용한다. 

#### 👉 문제점
앨리스가 Bob 과 앨리스의 통신기록을 모두 기록했다고 치자. 추후 Bob의 개인키를 알아내어 복화해서 모든 통신기록을 복호화해서 세션키와 세션키를 통한 대화내용을 모두 얻을 수 있게된다는 단점이 있다.

#### 👉 해결방법
현재에만 안전한 것이 아니라, 미래에 개인키가 유출되어도 안전하게 하는 보안 목표를 ```'순방향 비밀성'``` 혹은 ```'완전 순방향 비밀성 (perfect forward secrecy, PFS)'```이라고 한다.
RSA에는 순방향 비밀성이 제공되지 않는다. (????? 그럼 RSA말고 다른 알고리즘을 사용하는게 해결방법이라는건가??)

### 🔸 Diffie Hellman
최초의 공개키 알고리즘으로, 보안에 취약하다는 단점이 있다.


## 📝 References
[암호화 복호호화 개념 및 장/단점](https://velog.io/@yanghl98/Network-%EB%8C%80%EC%B9%AD%ED%82%A4%EA%B3%B5%EA%B0%9C%ED%82%A4-Symmetric-KeyPublic-Key)
[암호화 복호화 장/단점 및 특징](https://retro-blue.tistory.com/40)






