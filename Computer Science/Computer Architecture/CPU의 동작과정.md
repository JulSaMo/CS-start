//2022.08.09 Noel



# ❤️ 중앙처리장치(CPU)의 작동 원리

CPU는 컴퓨터에서 가장 핵심적인 역할을 수행하는 부분, '인간의 두뇌'에 해당

크게 연산장치, 제어장치, 레지스터 3가지로 구성

![img](https://velog.velcdn.com/images%2Fckstn0777%2Fpost%2F38b86436-e0ab-4d2e-b9c6-30836c84e4a1%2Fimage.png)

| 구분                                           | 내용                                                         |
| ---------------------------------------------- | ------------------------------------------------------------ |
| **연산장치(ALU)**<br />(=산술, 논리 연산 장치) | - <u>산술연산(+,-,÷,x)과 논리연산(논리곱,논리합,부정 등)을 수행</u><br />- 연산에 필요한 데이터를 레지스터에서 가져오고, 연산결과를 다시 레지스터로 보내 저장 |
| **제어 장치**                                  | - <u>명령어를 순서대로 실행할 수 있도록 제어</u>하는 장치<br />- 주기억장치에서 프로그램  명령어를 꺼내 해독 후, 해독결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄 <br />- 또한 이들 장치가 보낸 신호를 받아 다음에 수행할 동작을 결정 |
| **레지스터**                                   | - CPU의 속도와 비슷한 고속의 기억장치<br />- 명령어 주소, 명령어 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장<br />- CPU의 종류에 따라 사용할 수 있는 레지스터의 개수와 크기가 다름<br />- 용도에 따라 범용 레지스터와 특수 목적 레지스터로 구분<br />   > 범용 레지스터 : 연산에 필요한 데이터나 연산결과를 임시로 저장 <br />   > 특수 목적 레지스터 : 특별한 용도로 사용되는 레지스터, 용도와 기능에 따라 구분 |
| CPU 내부 버스                                  | - ALU와 레지스터들 간의 데이터 이동을 위한 데이터, 주소 선들. 제어 장치로 부터 발생되는 제어 신호를 전송하는 선들로 구성 |


<br/>
#### 🧡 특수 목적 레지스터 중 중요한 것들  

| 구분                           | 내용                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| **메모리 버퍼 레지스터 (MBR)** | 주기억장치에서 읽어온 데이터나 저장할 데이터를 임시로 저장 <br/>(주기억장치와 CPU 사이의 속도를 맞추기 위한 완충제 역할) |
| **메모리 주소 레지스터 (MAR)** | 읽기와 쓰기 연산을 수행할 주기억장치의 주소를 저장           |
| **명령어 레지스터(IR)**        | 현재 실행 중인 명령어를 저장                                 |
| **명령어 해독기**              | 명령어 레지스터에 있는 명령어의 연산코드를 전달받아 해독한 뒤, 수행할 연산을 결정하여 연산장치에 전달 |
| **프로그램 카운터(PC)**        | 다음에 수행할 명령어의 주소를 저장                           |
| **누산기 (AC)**                | 연산 결과를 임시로 저장                                      |

<br/>

<hr/>
<br/>


# ❤️ CPU 동작과정

<img width="948" alt="image" src="https://user-images.githubusercontent.com/103012104/183633980-de00b26d-fef6-4b22-86e7-d303ea4d2f9f.png">

| 순서 | 장치                | 하는 일                                                      |
| ---- | ------------------- | ------------------------------------------------------------ |
| 0    | **주기억장치(RAM)** | 입력장치에서 입력받은 데이터(또는 보조기억장치에 저장된 프로그램)을 읽어옴 |
| 1    | **CPU**             | 처리해야할 데이터를 주기억장치(RAM)에서 불러와 -> 제어장치 안의 레지스터1에 전달 |
| 2    | **제어장치**        | 연산코드를 해석하고 무슨 연산을 해야하는지 결정해서 연산장치(ALU)한테 전달 |
| 3    | **연산장치**        | 연산한다                                                     |
| 4    | **주기억장치(RAM)** | 주기억장치는 처리결과를 보조기억장치에 저장하거나 출력장치로 보냄 |
| -    | **제어장치**        | 제어장치는 전 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어 |


<br/>
#### 2번의 제어장치의 동작과정

<img width="948" alt="image" src="https://user-images.githubusercontent.com/103012104/183634060-5bbe56b7-d803-46be-a220-a07c53e4ffcc.png">

| 순서 | 장치                   | 하는 일                                                      |
| ---- | ---------------------- | ------------------------------------------------------------ |
| 1    | **주기억장치(RAM)**    | 현재 프로그램카운터(PC)에 있는 주소(이번에 실행될 명령어 주소)에 해당하는 명령어를 가져와 명령어 레지스터에 넣음<br/>(그림에서는 카운터의 현재 주소가 M1이라, RAM에서 M1에 해당하는 명령어가 명령어 레지스터에 들어감) |
| 2    | **제어장치**           | 가져온 명령어는 "연산코드"와 "데이터"로 분리된다. (명령어 구조가 그렇게 생겼기 때문) <BR/>"연산코드"→ "명령어 레지스터"로 가고,<BR/> 나머지 데이터 → "기억장치 주소 레지스터"를 넘겨 "주기억창치"로 넘어감 |
| 3    | **프로그램카운터(PC)** | 다음 실행할 명령어 주소를 바꿈<br/>사진 상에는 M1이 끝났으니까 다음 명령어인 M2로 바뀔 예정 |
| 4    | **제어장치**           | 카운터가 2번 하는 동안, 명령어 해석기에 들어간 "연산코드"는 해석되어 무슨 연산을 할지 결정한 후 연산장치에 넘어간다. |
| 5    | **연산장치(ALU)**      | 4번에서 받은 연산을 할건데, <br/>연산에 필요한 데이터는 2번의 "기억장치 주소 레시스터"를 넘겨, 주기억창치로 넘어간 데이터가 이때 여기로 넘어와 연산된다. |


<br/>
#### CPU의 동작과정

<img width="939" alt="image" src="https://user-images.githubusercontent.com/103012104/183634101-6cfc7481-fd5f-414a-b98e-90b73d8db696.png">


<br/>
<hr/>
<br/>


# 명령어 세트(instruction Set)

- 어떤 CPU가 실행할 명령어의 집합

- CPU는 프로그램을 실행하기 위해 주기억장치에서 명령어를 순차적으로 인출하고 해독하고 실행하는 과정을 반복함

- 명령어 세트 = 연산 코드(Operation Code) + 피연산자(Operand)로 이루어짐

  | 구분                           | 하는 일                                                      |
  | ------------------------------ | ------------------------------------------------------------ |
  | 연산 코드<br/>(Operation Code) | 실행할 연산을 지정 / <br/>연산, 제어, 데이터 전달, 입출력 기능을 가짐 |
  | 피연산자<br/>(Operand)         | 연산을 수행하는데 필요한 필요한 데이터 or 데이터 주소를 나타냄 /  <br/>주소, 숫자/문자, 논리 데이터 등을 저장 |


<br/>
#### 명령어 포맷

![img](https://velog.velcdn.com/images%2Fckstn0777%2Fpost%2Fd87e12c6-d26e-4e45-8dfb-edd5ec89fc57%2Fimage.png)

- 명령어 포맷은 일반적으로 **Opcode(명령코드)**와 피연산자를 나타내는 Operand의 데이터나 데이터의 주소를 가집니다.
- Opcode(명령코드)는 기계어의 일부이며 수행할 명령어를 나타내는 부호를 말합니다.
  - 이에 대한 규격과 형식은 CPU 명령어 집합에 나와 있습니다. 
  - 여기서는 아래와 같이 Opcode가 존재한다고 한다고해보겠습니다.
  - Operand는 하나 이상의 지정자를 가집니다. 일부 연산에 대하서는 연산 자체가 묵시적으로 피연산자를 갖고 있는 경우도 있고, 피연산자를 아예 갖지 않는 연산도 있습니다.

  > 결론적으로 Opcode(명령코드)도 컴퓨터마다 다르고, 명령어 포맷도 컴퓨터마다 다름. (아래는 예시일뿐)

<img width="718" alt="image" src="https://user-images.githubusercontent.com/103012104/183634825-56c01808-28f6-4fd5-91be-325280aaeb1a.png">


<br/>
<hr/>
<br/>


# ❤️CPU 명령어 사이클 (Instruction Cycle)

명령어 사이클(Instruction Cycle) : CPU가 프로그램을 실행을 위해 **주기억장치에서 명령어를 가져오고 해독하고 실행하는 것을 반복하는 과정**

- 명령어 사이클은 **인출 → 실행  → 간접  → 인터럽트**로 나뉨

<img width="958" alt="image" src="https://user-images.githubusercontent.com/103012104/183634887-bf499536-a60b-4465-8b1f-4fdcbacbc538.png">

<img width="953" alt="image" src="https://user-images.githubusercontent.com/103012104/183634952-37407745-9964-411e-b2cf-36c4ab7eab91.png">

| 명령 사이클                                 | 내용                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| **인출 사이클 <br/>(Fetch Cycle) **         | - 주기억장치로부터 수행할 명령어를 CPU로 가져오는 단계<br/>- 하나의 명령을 수행한 후 다음 명령을 메인 메모리에서 CPU로 꺼내 오는 단계<br />- 명령어의 Operand가 간접 주소인 경우 : 간접 사이클로 진행<br />- 명령어의 Operand가 직접 주소인 경우 : 실행 사이클로 진행 |
| **간접 사이클 <br/>(Indirect Cycle) **      | - 명령어의 Operand가 간접주소 지정이 된 경우, 유효 주소를 계산하기 위해 주기억장치에 접근하는 단계<br />- 명령의 실행을 위해 실행 사이클(Execute Cycle)로 진행됨<br />-명령어에 포함되어 있는 주소를 이용해, 그 명령어 실행에 필요한 데이터의 주소를 인출하는 사이클 |
| **실행 사이클 <br/>(Execute Cycle) **       | - CPU가 명령의 해독결과 이에 해당하는 타이밍 및 제어신호를 순차적으로 발생시켜 실제로 명령어를 실행하는 단계<br />- 명령어 코드를 해독하고, 그 결과에 따라 필요한 연산들을 수행<br />- 실행 사이클에서 수행되는 마이크로 연산들은 명령어에 따라 다름 |
| **인터럽트 사이클 <br/>(Interrupt Cycle) ** | - 인터럽트 발생 시 인터럽트 처리를 위한 단계<br />-인터럽트에 대한 처리가 완료되면 Fetch Cycle 진행 |


<br/>
#### 기본적인 명령어 사이클 과정 (인출 사이클 + 실행 사이클)

- Instruction Cycle =  인출 사이클 (Fetch Cycle) + 실행 사이클 (Execute Cycle)
  - 인출 사이클 (Fetch Cycle) : 주기억장치로부터 명령어와 데이터를 CPU로 가져오는 단계
  - 실행 사이클 (Execut Cycle) : CPU가 수행하는 단계
- Instruction Cycle 과정
<img width="978" alt="image" src="https://user-images.githubusercontent.com/103012104/183635005-a60f4271-60ff-4204-8f02-192e6b8e271b.png">

| 순서 | 구분                                     | 내용                                                         |
| ---- | ---------------------------------------- | ------------------------------------------------------------ |
| 1    | **명령어 인출<br/>(Instruction fetch)**  | 주기억장치에서 필요한 명령어 주소를 계산하고 그 주소로 가서 명령어를 순차적으로 가져옴 |
| 2    | **명령어 해독<br/>(Instruction decode)** | 제어장치에서 호출된 명령어 해독 (어떻게 수행, 행위, 동작 시킬 지 결정) |
| 3    | **데이터 인출<br />(Data fetch)**        | 피연산자(=연산할 대상)의 위치를 계산해서 불러옴              |
| 4    | **데이터 처리<br/>(Data process)**       | 해석된 명령어를 산술/논리 연산장치를 통해 실행               |
| 5    | **데이터 저장<br/>(Data store)**         | 연산 후 수행 결과를 주기억장치에 저장                        |

*이후 1번부터 끊임없이 반복 수행

<br/>

### CPU 명령어 처리 과정

#### 인출 사이클과 실행 사이클에 의한 명령어 처리과정

- 인출 사이클에서 가장 중요한 부분은 PC (프로그램 카운터) 값 증가

![img](https://velog.velcdn.com/images%2Fckstn0777%2Fpost%2F9e3f0d10-268a-4517-b3e4-816304f23356%2Fimage.png)

| 순서 | 구분                                                | 내용                                                         |
| ---- | --------------------------------------------------- | ------------------------------------------------------------ |
| 1    | **MAR(메모리 주소 레지스터) ← PC(프로그램 커운터)** | - 다음에 실행할 명령어의 주소가 있는 PC의 값을 MAR에 저장시켜줍니다.<br/>- PC의 값이 외부의 주소버스로 가기 위해서는 MAR을 거쳐야합니다. |
| 2    | **MBR ← M[MAR], <br/>PC ← PC + 1**                  | MAR을 거쳐서 외부로 나가고, 메모리(M)의 값을 찾아 데이터 버스를 타고 MBR에 저장시켜줍니다. <br/>그런 다음 PC 값은 1 증가시켜줍니다. |
| 3    | **IR ← MBR**                                        | MBR에 저장된 내용을  명령어 레지스터(IR)에 전달              |


<br/>
#### 인출한 이후, 명령어를 실행하는 과정

![img](https://velog.velcdn.com/images%2Fckstn0777%2Fpost%2Fd12ce7f1-0be8-4663-a1d8-f6046f044679%2Fimage.png)

아래의 1~4번은 필수적인 과정이 아니라, 명령어에 따라 달라짐

1. 데이터 이동: CPU와 기억장치,I/O장치 간에 데이터를 이동합니다. / ex) `LOAD addr`
2. 데이터 처리: 데이터에 대하여 산술,논리 연산을 수행합니다.  / ex) `STA addr`
3. 데이터 저장: 연산결과 데이터나 입력장치로부터 읽어들인 데이터를 기억장치에 저장합니다. / ex) `ADD addr`
4. 프로그램 제어: 프로그램의 실행 순서를 결정합니다. / ex) `JUMP addr`


<br/>
##### 3번 ADD addr의 명령어 연산

```
T0 : MAR ← IR(Addr)
T1 : MBR ← M[MAR]
T2 : AC ← AC + MBR
```

이미 인출이 진행되고 명령어만 실행하면 되기 때문에 PC를 증가할 필요없음

IR에 MBR의 값이 이미 저장된 상태를 의미

따라서 AC에 MBR을 더해주기만 하면됨



출처

https://foxtrotin.tistory.com/144

https://velog.io/@ckstn0777/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-9htxi9jo

https://moz1e.tistory.com/202

https://m.blog.naver.com/dilector/221786016166

