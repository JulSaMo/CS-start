// 2022.07.28

// Seonghun Jeon (Jack)

# 패러티 비트(Parity Bit) & 해밍 코드(Hamming Code)



## 🔗 패러티 비트(Parity Bit) 란?

정보의 전달 과정에서 오류가 생겼는지를 검사하기 위해 추가된 비트
패러티 비트는 시리얼 통신에서 송수신되는 데이터의 오류를 검출하기 위해서 사용되는 일종의 오류식별자이다.



## 😅 패러티 비트의 정의는 알겠고... 그럼 패러티와 비트를 쪼개볼까?

패러티(Parity)는 수학적 정의로 홀수와 짝수를 나타낸다.
비트(Bit)는 데이터를 나타내는 최소 단위. 모든 데이터는 0과 1의 조합으로 구성되는데, 이 0또는 1이 하나의 비트가 된다.
즉, 이 둘을 합치면 홀수와 짝수를 나타내는 비트라고 볼 수 있다!

그렇다면 정보의 전달 과정에서 오류가 생겼는지 검사하는 것과 홀수와 짝수를 나타내는 이 패러티 비트가 무슨 상관인걸까?

우선은 비트에 대한 개념을 조금 더 자세하게 보고 넘어가자



## 🔗 비트(Bit)와 바이트(Byte)에 관하여...

비트는 컴퓨터가 처리할 수 있는 가장 작은 단위이다.
0 or 1의 정보를 담을 수 있다.
2진수로 이루어져 있어 Binary Digit으로 불린다.
1bit -> 2 / 2bit -> 2*2 / 3bit -> 2*2*2 와 같이 비트가 하나 증가할 때마다 표현할 수 있는 정보의 개수는 *2씩 늘어난다.

비트를 이야기할 때 빠질 수 없는 것이 Byte이다.
Byte는 프로그램에서 데이터를 처리할 때 가장 기본적인 단위이다.
1Byte = 8Bits = 2^8

우리가 읽고 쓰는 문자에 대한 표현은 어떤 방식으로 이루어 질까?
아스키(ASCII)라는 미리 약속해둔 룰을 기반으로 문자(String)도 이진법으로 표시하여 사용한다.
하지만 아스키 코드는 문자에 대한 한계가 있어(한국어도 없음) Unicode가 이를 보완한다. 지구상의 거의 모든 문자열을 포함하고 있는 Unicode이기에 너무 양이 방대해서 2Byte ~ 4Byte로 표현하고 있다.

우리가 잘 모르고 넘어가는 것 중 하나는 킬로바이트와 키비바이트의 차이다

kilobyte -> KB -> 1000Byte -> 1000
megabyte -> MB -> 1000KByte -> 1000^2Bytes
gigabyte -> GB -> 1000MByte -> 1000^3Bytes 
terabyte -> TB -> 1000GByte -> 1000^4Bytes

kibibyte -> KB -> 1024Byte -> 2^10Bytes
mebibyte -> MB -> 1024KByte -> 2^20Bytes
gibibyte -> GB -> 1024MByte -> 2^30Bytes
tebibyte -> TB -> 1024GByte -> 2^40Bytes

킬로바이트는 십진법, 키비바이트는 이진법 기준으로 이루어져있다!



## 🔗 패러티 비트로 다시 넘어와보자!

위의 글에서 패러티 비트는 '홀수와 짝수를 나타내는 비트'라고 명명하였다.
그 이유가 그래서 뭘까? 그것은 바로 홀수 패러티 방식과 짝수 패러티 방식을 이용하여 정보 송수신 과정에서 에러가 발생하는지 확인할 수 있기 때문이다.

그렇다면 홀수 패러티, 짝수 패러티 방식은 뭘까?
홀수 패러티 방식: 해당 범위의 비트에 들어있는 1의 개수를 홀수로 만들어주는 패러티 비트
-> 비트 중 1의 개수가 홀수개이면 오류가 없는것
짝수 패러티 방식: 해당 범위의 비트에 들어있는 1의 개수를 짝수로 만들어주는 패러티 비트
-> 비트 중 1의 개수가 짝수개이면 오류가 없는것
위와 같이 정의할 수 있다!

1. 홀수 짝수의 방식을 이용하여 오류를 검출해내기 때문에 패러티 비트라는 이름이 붙음
2. 패러티 비트는 정보의 송수신 과정에서 에러 발생 여부를 인지할 수 있음

자 여기까지 내용이 정리되었다. 그렇다면 오류가 왜 발생하는지 그리고 통신은 어떻게 이루어지는지를 훑어보고 오자!



## 📞 통신에 관하여...

통신은 직렬 통신과 병렬 통신으로 이루어진다.
직렬 통신은 대게 하나의 신호선을 이용하여 데이터를 주고받는 통신을 일컬어 지칭한다. 하나의 신호선을 이용하기 때문에 데이터 전송은 일정한 시간 간격으로 전송한다. 즉 한시간 간격 동안에 하나의 논리적인 데이터인 0과 1을 보내며, 일정한 길이의 데이터를 모두 전송하기 위해서는 다소 시간이 소요된다. 하지만 직렬 통신은 적은 수의 신호선을 사용하기 때문에 저렴하게 통신을 할 수 있다. 이런 장점 때문에 최근에 대부분의 통신은 직렬통신으로 데이터를 전송한다.

병렬 통신은 여러 개의 신호선을 사용한다. 신호선의 개수는 하나의 시간 간격 동안에 전송되는 데이터의 크기에 따라서 달라지는데, 일반적으로 8Bit, 16Bit, 32Bit의 데이터 선과 제어 신호선으로 구성된다. 이렇게 많은 선을 사용하므로 단위 시간당 전송되는 데이터 Bit의 양은 많지만, 통신 거리가 길어지게 될 경우에 이런 수많은 선을 모두 연장해야 하므로 통신 비용이 매우 크다. 또한 최근 다양한 기능의 단말 장치들이 계속해서 소형화되어가는 현실에서 데이터 통신을 위해 구성해야하는 I/O 단자의 크기를 크게 줄일 수 없기 때문에 병렬 통신은 쇠퇴의 길을 걷고 있다.

이렇게 최근엔 주로 직렬 통신으로 통신이 이루어지고 있다. 직렬 통신으로 데이터를 송수신하는 과정에서 각 비트를 단위시간당 하나씩 보내게 되어있는데, 이때 알 수 없는 요인에 의해서 비트의 값이 틀어져 1이 0으로 바뀌거나 0이 1로 바뀌는 경우가 있다. 
바로 이때 오류가 있는지 없는지 확인하기 위한 수단으로 패러티 비트가 쓰이는 것이다.



## 🔗 패러티 비트로 다시 넘어와서 정리해보자!

패러티 비트를 정하여 데이터를 보내면 받는 쪽에서 수신된 데이터의 전체 비트를 계산하여 패러티 비트를 다시 계산함으로써 데이터 오류 발생 여부를 알 수 있다.
직렬 통신을 하면서 데이터가 손실되어 패러티 비트에 의한 데이터 손실이 발생함을 인지하였을 때에는 수신지에서 다시 데이터를 보내달라는 재송신 요청을 할 수 있도록 하는 보다 안정적인 통신을 위한 하나의 보호장치라고 할 수 있다.

그러나 패러티 비트는 오류 발생 여부만 알 수 있고 오류를 수정할 수 없다는 단점도 지니고 있다.



## 👻 패러티 코드에 대해 교과서적인 지식은 알겠어... 근데 어떻게 적용해?

![스크린샷 2022-07-28 오후 4.20.25](/Users/seojeon22/Documents/스크린샷 2022-07-28 오후 4.20.25.png)

![스크린샷 2022-07-28 오후 4.20.45](/Users/seojeon22/Library/Application Support/typora-user-images/스크린샷 2022-07-28 오후 4.20.45.png)

짝수 패러티의 경우 데이터의 합이 짝수가 되게 만들어야 한다.

현재 데이터는 1 + 1 + 1 + 1 + 0 + 0 + 0 으로 합이 짝수이다.

그러므로 맨 뒤 패러티 비트는 0이 된다.

이때 만약 1110000으로 송신한 정보가 일부 유실되어 맨 앞자리 '1'이 전송되지 않았다고 하더라도 짝수 패러티 방식을 적용하고 있기에 맨 앞자리 1bit의 값이 '1'이었다는 것을 예측 할 수 있다.

이렇게 패러티 비트를 이용하면 1bit의 데이터 오류를 검출할 수 있지만 2개의 bit 오류가 발생했을 경우 검출할 수 없다.

따라서 이 문제점을 해결하기 위해 병렬 패러티, 해밍코드 등을 이용한다.



## 🐳 해밍코드로 넘어가보자

수학자 리처드 웨슬리 해밍(Richard Wesley Hamming)이 1940년대 말에 벨 연구소에서 개발하였다. 그의 이름을 따서 Hamming Code라고 명명되었다.

해밍코드는 데이터비트에 몇 개의 체크비트가 추가된 코드이다.

기존의 체크비트들은 수신된 데이터열에 에러가 있다 없다 정도만 확인 할 수 있었는데, 해밍코드를 이용하면 수신단은 에러비트의 위치까지 알 수 있게 할 뿐만 아니라 정정할 수도 있다.

꽤 많은 체크비트가 추가되므로, 비효율적이라 여길 수도 있으나 장점도 있다. 예를들어 Digital TV처럼 real time으로 데이터가 전송되어야 하는 경우, 데이터 전송과 동시에 에러정정이 수행돼야 했고, 이런 신뢰도 특징을 기반으로 대부분의 마이크로칩 디바이스에서도 사용되고 있다. 혹은 초장거리 데이터전송중(예를들면 위성통신...) 에러가 발생할 때, 수신단에서 에러 발견 후, 재송신을 요청하고... 다시 보내고 하면 더 큰 비효율을 초래하기도 한다.



## ✅ 얼마나 많은 체크비트가 필요할까?

2^p >= d + p + 1

d == 데이터 비트 / p == 체크 비트

데이터 비트가 8비트라면 체크 비트는 최소 4가 되어야함을 알 수 있다!



## 🐳 체크비트를 삽입하여 해밍코드를 적용해보자!

![스크린샷 2022-07-28 오후 4.39.10](/Users/seojeon22/Library/Application Support/typora-user-images/스크린샷 2022-07-28 오후 4.39.10.png)

최소비트가 오른쪽 맨 끝으로 온다.

총 비트수는 데이터 8비트, 체커 4비트 총 12비트이다.

각 체크비트의 위치는 2^n의 순서대로 삽입된다.

즉, 1 2 4 8 번째 위치에 삽입된다.

나머지 비어있는 위치엔 데이터 8비트를 넣어준다.

그 후 패러티 체킹을 진행한다!



## ✔️ 패러티 체킹하는 방법!

2^0에서 시작해서 2^0칸씩 띄우고 2^0칸씩 전부 더한게 홀수/짝수 패러티![스크린샷 2022-07-28 오후 4.43.10](/Users/seojeon22/Library/Application Support/typora-user-images/스크린샷 2022-07-28 오후 4.43.10.png)

2^1에서 시작해서 2^1칸씩 띄우고 2^1칸씩 전부 더한게 홀수/짝수 패러티![스크린샷 2022-07-28 오후 4.43.24](/Users/seojeon22/Library/Application Support/typora-user-images/스크린샷 2022-07-28 오후 4.43.24.png)

2^2에서 시작해서 2^2칸씩 띄우고 2^2칸씩 전부 더한게 홀수/짝수 패러티![스크린샷 2022-07-28 오후 4.43.35](/Users/seojeon22/Library/Application Support/typora-user-images/스크린샷 2022-07-28 오후 4.43.35.png)



## 👏 패러티 체킹이 끝나면?

송신된 신호의 체크비트열과 수신된 체크비트를 비교해준다.

예를들면 송신된 신호의 체크비트열은 0011인데, 수신된 체크비트가 1001이면

두번째와 네번째 비트에서 기대값과 다른 값이 수신된 것으로, 두번째와 네번째 오류가 생긴 오류확인비트는 1010이 될 것이다. 이 때 이 수를 십진법으로 바꾸면 1010 = 10이므로, 10번째 비트에 오류가 생긴 것으로 볼 수 있다. 즉 수신된 비트열에서 D10을 뒤집으면 오류 정정 끝!



##  👻 예제로 알아봅시다!

01010101이라는 8비트 데이터를 송신하고자 한다.

![스크린샷 2022-07-28 오후 5.18.15](/Users/seojeon22/Library/Application Support/typora-user-images/스크린샷 2022-07-28 오후 5.18.15.png)

![스크린샷 2022-07-28 오후 5.18.28](/Users/seojeon22/Library/Application Support/typora-user-images/스크린샷 2022-07-28 오후 5.18.28.png)

![스크린샷 2022-07-28 오후 5.19.06](/Users/seojeon22/Library/Application Support/typora-user-images/스크린샷 2022-07-28 오후 5.19.06.png)



### Reference

< 비트와 바이트 >

https://www.youtube.com/watch?v=5IRFJt1C5o4

< 패러티 비트 >

https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=ansdbtls4067&logNo=220886661657

https://dololak.tistory.com/33

< 해밍코드 >

https://m.blog.naver.com/ggggamang/221113176831